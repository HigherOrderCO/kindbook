// Applies a monadic function to each element of a list, threading a state through the computation.
// - M: The monad type constructor.
// - m: The Monad instance for M.
// - A: The type of elements in the list.
// - S: The type of the state.
// - xs: The list of elements to process.
// - s: The initial state.
// - f: The monadic function that takes the current state and list element, and returns a new state.
// = A monadic value containing the final state after processing all elements.
List/for-given
: ∀(M: ∀(A: *) *)
  ∀(m: (Trait/Monad M))
  ∀(A: *)
  ∀(S: *)
  ∀(xs: (List A))
  ∀(s: S)
  ∀(f: ∀(s: S) ∀(a: A) (M S))
  (M S)
= λM λm λA λS λ{
  #Nil: λs λf (Trait/Monad/pure M m S s)
  #Cons: λhead λtail λs λf 
    (Trait/Monad/bind M m S S (f s head) (λx (List/for-given M m A S tail x f)))
}

// Test: Empty list with Maybe monad
TEST_0
: (Equal
    (Maybe Nat)
    (List/for-given Maybe MT/Monad Nat Nat (List/Nil Nat) #Zero (λs λx (#Some{(Nat/add s x)})))
    (#Some{#Zero}))
= #Refl

// Test: Non-empty list with Maybe monad
TEST_1
: (Equal
    (Maybe Nat)
    (List/for-given Maybe MT/Monad Nat Nat
      (List/Cons _ #1
        (List/Cons _ #2
          (List/Cons _ #3
            (List/Nil _))))
      #Zero
      (λs λx (#Some{(Nat/add s x)})))
    (#Some{#6)
  )
= #Refl

// Test: Maybe monad with potential failure
TEST_2
: (Equal
    (Maybe Nat)
    (List/for-given Maybe MT/Monad Nat Nat
      (List/Cons _ #1
        (List/Cons _ #Zero
          (List/Cons _ #2
            (List/Nil _))))
      #10
      (λs λx
        (Bool/if (Maybe Nat)
          (Nat/eq x #Zero)
          (#None)
          (#Some{(Nat/sub s x)}))))
    (#None))
= #Refl