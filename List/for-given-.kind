use List/ as L/
use Trait/ as T/
use Equal/ as E/
use Maybe/Trait/ as MT/
use Maybe/ as M/
use Bool/ as B/
use Nat/ as N/

// Test: Empty list with Maybe monad
T0
: (E/Equal
    (M/Maybe N/Nat)
    (L/for-given M/Maybe MT/Monad N/Nat N/Nat (L/Nil N/Nat) #Zero{} (λs λx (#Some{(N/add s x)})))
    (#Some{#Zero{}}))
= #Refl{}

// Test: Non-empty list with Maybe monad
T1
: (E/Equal
    (M/Maybe N/Nat)
    (L/for-given M/Maybe MT/Monad N/Nat N/Nat
      (L/Cons _ #Succ{#Zero{}}
        (L/Cons _ #Succ{#Succ{#Zero{}}}
          (L/Cons _ #Succ{#Succ{#Succ{#Zero{}}}}
            (L/Nil _))))
      #Zero{}
      (λs λx (#Some{(N/add s x)})))
    (#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}})
  )
= #Refl{}

// Test: Maybe monad with potential failure
T2
: (E/Equal
    (M/Maybe N/Nat)
    (L/for-given M/Maybe MT/Monad N/Nat N/Nat
      (L/Cons _ #Succ{#Zero{}}
        (L/Cons _ #Zero{}
          (L/Cons _ #Succ{#Succ{#Zero{}}}
            (L/Nil _))))
      #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}
      (λs λx
        (B/if (M/Maybe N/Nat)
          (N/eq x #Zero{})
          (#None{})
          (#Some{(N/sub s x)}))))
    (#None{}))
= #Refl{}