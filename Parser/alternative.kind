// Combines two parsers, trying the second if the first fails.
// - A: The type of the value to be parsed.
// - p: The first parser to try.
// - q: The parser to try if the first fails.
// = A new parser that succeeds if either of the input parsers succeeds.
Parser/alternative : âˆ€(A: *) (Parser A) -> (Parser A) -> (Parser A)
| A p q state = match (p state) {
  #Done{r}: #Done{r}
  #Fail{_}: (q state)
}

#test: (Parser/run U32 (Parser/alternative U32 (Parser/pure U32 1) (Parser/pure U32 2)) "") == #Some{1}
#test: (Parser/run U32 (Parser/alternative U32 (Parser/fail U32 "Error") (Parser/pure U32 2)) "") == #Some{2}
#test: (Parser/run U32 (Parser/alternative U32 (Parser/fail U32 "Error 1") (Parser/fail U32 "Error 2")) "") == #None