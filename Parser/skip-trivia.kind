// Checks if a character is a newline
Pair/is-newline
: ∀(c: Char)
  Bool
= λc (Char/eq c 10) // 10 is the ASCII code for newline

// Checks if a list of characters starts with "//"
Pair/is-comment
: ∀(cs: (List Char))
  Bool
= λ{
  #Cons: λhead λ{
    #Cons: λsecond λtail (Bool/and (Char/eq head 47) (Char/eq second 47))
    #Nil: #False{}
  }
  #Nil: #False{}
}

// Helper function to handle comment skipping
Pair/skip-comment
: ∀(acc: Nat)
  ∀(cs: (List Char))
  (Pair/Pair Nat (List Char))
= λacc λcs
  let com-len = (List/length _ (List/take-while _ (λc (Bool/not (Pair/is-newline c))) cs))
  let new-acc = (Nat/add (Nat/add acc #2) com-len) // +2 for "//"
  let rem     = (List/drop _ (#Succ{com-len}) cs) // +1 to consume newline
  (Pair/skip-trivia-go new-acc rem)

// Auxiliary function for skip-trivia
// Accumulates the number of skipped characters
Pair/skip-trivia-go
: ∀(acc: Nat)
  ∀(cs: (List Char))
  (Pair/Pair Nat (List Char))
= λacc λ{
  #Nil: (Pair/Pair.new _ _ acc #Nil{})
  #Cons: λc λcs
    (Bool/if (Pair/Pair Nat (List Char))
      (Char/is-space c)
      (Pair/skip-trivia-go (#Succ{acc}) cs)
      (Bool/if (Pair/Pair Nat (List Char))
        (Pair/is-comment (#Cons{c cs}))
        (Pair/skip-comment acc cs)
        (Pair/Pair.new _ _ acc (#Cons{c cs}))))
}

// Skips whitespace and comments in the text.
// Returns the number of characters skipped.
Pair/skip-trivia
: (Pair/Parser Nat)
= λs
  let input = (Pair/State/input s)
  let chars = input
  let skipped = (Pair/skip-trivia-go #Zero{} chars)
  let skp = (Pair/Pair/fst _ _ skipped)
  let rem = (Pair/Pair/snd _ _ skipped)
  let new-index = (Nat/add (Pair/State/index s) skp)
  let new-input = rem
  #Done{#MkReply{
    state: #MkState{input: new-input index: new-index}
    value: skp
  }}
