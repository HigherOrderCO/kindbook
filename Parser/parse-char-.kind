use Parser/ as PS/
use Result/ as R/
use String/ as S/
use Char/ as C/
use Equal/ as E/
use Nat/ as N/

// Test: Parsing a normal character
T0 
: (E/Equal
  (R/Result (PS/Reply C/Char) PS/Error)
  (PS/parse-char (PS/State/new "abc" #Zero))
  (#Done{#MkReply{#MkState{"bc" #Succ{#Zero}} 'a'}})
)
= #Refl

// Test: Parsing an escaped newline character
T1 
: (E/Equal
  (R/Result (PS/Reply C/Char) PS/Error)
  (PS/parse-char (PS/State/new "\\nabc" #Zero))
  (#Done{#MkReply{#MkState{"abc" #Succ{#Succ{#Zero}}} '\n'}})
)
= #Refl

// // Test: Parsing a Unicode escape sequence
// T2 
// : (E/Equal
//   (R/Result (PS/Reply C/Char) PS/Error)
//   (PS/parse-char (PS/State/new "\\u{1F600}abc" #Zero))
//   (#Done{#MkReply{#MkState{"abc" #9} 'ðŸ˜€'}})
// )
// = #Refl

// Test: Parsing an invalid escape sequence
T3 
: (E/Equal
  (R/Result (PS/Reply C/Char) PS/Error)
  (PS/parse-char (PS/State/new "\\xabc" #Zero))
  (#Fail{#MkError{#Succ{#Succ{#Zero}} "Invalid escape character: x"}})
)
= #Refl