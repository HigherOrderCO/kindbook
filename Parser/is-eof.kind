use Parser/ as PS/
use Bool/ as B/
use Result/ as R/
use String/ as S/

// Checks if the parser has reached the end of the input.
// = A Reply containing a Bool: True if at the end of input, False otherwise.
PS/is-eof : (PS/Parser B/Bool)
= λstate
  let input = (PS/State/input state)
  let result = (S/is-empty input)
  #Done{
    #MkReply{
      state: state
      value: result
    }
  }

// Accessor for the input field of State
PS/State/input
: ∀(s: PS/State)
  S/String
= λ{
  #MkState: λs.input λs.index s.input
}
//TEST//

use Parser/ as PS/
use Bool/ as B/
use Equal/ as E/
use Result/ as R/
use String/ as S/

// Test: is-eof returns True for an empty string
T0
: (E/Equal
    (R/Result (PS/Reply B/Bool) PS/Error)
    (PS/is-eof (PS/State/new [] #Zero))
    (#Done{
      #MkReply{
        state: (PS/State/new [] #Zero)
        value: #True
      }
    })
  )
= #Refl

// Test: is-eof returns False for a non-empty string
T1
: (E/Equal
    (R/Result (PS/Reply B/Bool) PS/Error)
    (PS/is-eof (PS/State/new (S/from-list [97u32 98u32 99u32]) #Zero))
    (#Done{
      #MkReply{
        state: (PS/State/new (S/from-list [97u32 98u32 99u32]) #Zero)
        value: #False
      }
    })
  )
= #Refl