use Parser/ as PS/

// Represents the reply of a parser.
// - A: The type of the parsed value.
// = A record containing the current parser state and the parsed value.
PS/Reply : ∀(A: *) *
= λA data[]{
  #MkReply{
    state: PS/State
    value: A
  } : (PS/Reply A)
}

// Accessor for the state field of Reply
PS/Reply/state
: ∀(A: *)
  ∀(reply: (PS/Reply A))
  PS/State
= λA λ{
  #MkReply: λreply.state λreply.value reply.state
}

// Accessor for the value field of Reply
PS/Reply/value
: ∀(A: *)
  ∀(reply: (PS/Reply A))
  A
= λA λ{
  #MkReply: λreply.state λreply.value reply.value
}

// Helper function to create a new Reply
PS/Reply/new
: ∀(A: *)
  ∀(state: PS/State)
  ∀(value: A)
  (PS/Reply A)
= λA λstate λvalue #MkReply{state value}
//TEST//

use Parser/ as PS/
use Pair/ as P/
use String/ as S/
use Nat/ as N/
use Equal/ as E/

// Test: Verify Reply record field access
T0 : (E/Equal use x = (PS/Reply)
      (P/Pair PS/State N/Nat)
      (#Pair{
        (PS/Reply/state N/Nat (#MkReply{(#MkState{"abc" #0}) #42}))
        (PS/Reply/value N/Nat (#MkReply{(#MkState{"abc" #0}) #42}))})
      (#Pair{
        (#MkState{"abc" #0})
        #42}))
= #Refl