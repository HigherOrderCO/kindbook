use Bend/Fun/Book as Book
use Bend/Fun/FnDef as FnDef
use Bend/Fun/Rule as Rule
use Bend/Fun/Term as Term

// Returns a list of all recursive functions in a Book.
Book/recursive-defs : Book -> (List String)
| book@#Book{defs _ _} =
  let deps   = (book-deps book)
  let defs   = (List/map _ _ FnDef/get-nam (BinMap/values _ defs))
  let cycles = (book-cycles deps defs)
  (List/dedup _ String/Ord (List/concat _ cycles))

// Collect the direct function dependencies of a Book.
// That is, for each function, which functions appear as Ref in its body.
book-deps : Book -> (BinMap (BinMap String))
| #Book{defs adts ctrs} = (BinMap/map _ _ def-deps defs)

def-deps : FnDef -> (BinMap String)
| #FnDef{name type check rules src} =
  let deps = (List/concat-map Rule _ λ{#Rule{_ bod}: (term-deps bod)} rules)
  (BinMap/from-list _ (List/map _ _ (λdep #Pair{(String/hash dep) dep}) deps))

term-deps : Term -> (List String)
| #Ref{nam} = [nam]
| term      = (List/concat-map (Pair _ _) _ λ{#Pair{_ x}: (term-deps x)} (Term/children term))

// Return the list of all recursive function call cycles in a Book.
// - deps: The direct function dependencies of the Book.
// - defs: A list of names of all function definitions in the Book.
// = A list of lists of function names, where each list represents a cycle.
book-cycles : (BinMap (BinMap String)) -> (List String) -> (List (List String))
| deps defs =
  let initial = (List/map _ (Pair _ (List _)) λdef #Pair{def []} defs)
  (def-cycles deps (BinMap/new _) [] initial)

// Walks the dependency graph to find all cycles.
// TODO: Use a more efficient algorithm that doesn't need to check the entire path.
def-cycles : (BinMap (BinMap String)) -> (BinMap Unit) -> (List (List String)) -> (List (Pair String (List String))) -> (List (List String))
| deps visited cycles #Nil =
  cycles
| deps visited cycles #Cons{#Pair{nam path} to_visit} =
  if (BinMap/contains _ visited (String/hash nam)) {
    // Check if the current ref is already in the stack, which indicates a cycle.
    let cycles = (check-cycle nam path cycles)
    (def-cycles deps visited cycles to_visit)
  } else {
    let visited = (BinMap/set _ visited (String/hash nam) #Unit)
    let path    = #Cons{nam path} :: (List _)
    let new     = (get-new-deps deps nam path)
    (def-cycles deps visited cycles (List/append _ new to_visit))
  }

check-cycle : String -> (List String) -> (List (List String)) -> (List (List String))
| nam path cycles with (List/split-chunks _ (λx (String/eq nam x)) path)
. | #Cons{cycle #Cons{_ _}} = #Cons{#Cons{nam cycle} cycles}
. | _                       = cycles

get-new-deps : (BinMap (BinMap String)) -> String -> (List String) -> (List (Pair String (List String)))
| deps nam path with (BinMap/get _ deps (String/hash nam))
. | #Some{deps} = (List/map _ _ (λdep #Pair{dep path}) (BinMap/values _ deps))
. | #None       = #Nil
