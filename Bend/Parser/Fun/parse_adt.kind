use Bend/Parser/Fun/parse_adt as .
use Bend/Fun/Adt as Adt
use Bend/Fun/Ctr as Ctr
use Bend/Fun/CtrField as CtrField
use Bend/Fun/Type as Type
use Bend/Parser as BP
use Bend/Source as Source

// Parses a Fun syntax ADT definition.
// = The parsed ADT and the list of ADT constructors.
Bend/Parser/Fun/parse_adt : (Parser (Pair Adt (List Ctr)))
| = do Parser {
  ask _           = (BP/skp)
  ask ini_idx     = (Parser/get_index)
  ask _           = (BP/parse_keyword "type")
  ask _           = (BP/skp)
  ask (nam, vars) = (./parse_name_and_vars)
  ask ctrs        = (./parse_ctrs nam vars)
  ask end_idx     = (Parser/get_index)
  let src         = (Source/from_file_span ini_idx end_idx)
  let adt         = #Adt{nam vars (List/map _ _ ctrs Ctr/get_nam) src} :: Adt
  ret (adt, ctrs) :: (_ & _)
}

// Parses the name and type vars part of the ADT definition.
// = The ADT name and type variables.
./parse_name_and_vars : (Parser (Pair String (List String)))
| = do Parser {
  ask has_parens = (BP/try_consume "(")
  if has_parens do Parser {
    ask _    = (BP/skp)
    ask name = (BP/parse_name "datatype")
    ask vars = (BP/list_like _ (BP/parse_name "type variable") "" ")" "" #False 0)
    ask _    = (Parser/consume "=")
    ret (name, vars) :: (_ & _)
  } else do Parser {
    ask name = (BP/parse_name "datatype")
    ask vars = (BP/list_like _ (BP/parse_name "type variable") "" "=" "" #False 0)
    ret (name, vars) :: (_ & _)
  }
}

// Parses the constructors part of an ADT definition.
// - type_name: The name of the ADT being defined.
// - type_vars: The type variables of the ADT being defined.
// = A list of constructors.
./parse_ctrs : String -> (List String) -> (Parser (List Ctr))
| type_name type_vars = do Parser {
  // TODO: Check that only previously defined vars occur in the constructors.
  //       This probably needs to be done later, after we have the full book.
  ask head = (parse_ctr type_name type_vars)
  ask many = (BP/try_consume "|")
  ask tail = if many do Parser {
    (BP/sep_by _ (parse_ctr type_name type_vars) "|" 0)
  } else do Parser {
    ret [] :: (List _)
  }
  ret (head ;; tail) :: (List _)
}

// Parses a single constructor in an ADT definition.
parse_ctr : String -> (List String) -> (Parser Ctr)
| type_name type_vars = do Parser {
  // TODO: Check for repeated field names
  ask _          = (BP/skp)
  ask ini_idx    = (Parser/get_index)
  ask has_parens = (BP/try_consume "(")
  ask _          = (BP/skp)
  if has_parens do Parser {
    ask name    = (BP/parse_name "datatype constructor")
    let name    = (String/concat [type_name "/" name])
    ask fields  = (BP/list_like _ ./parse_field "" ")" "" #False 0)
    let type    = (List/foldr _ (List/map _ _ fields CtrField/get_typ) _
                    #Ctr{type_name (List/map _ Type type_vars 位x #Var{x})} :: Type
                    位l 位r #Arr{l r})
    ask end_idx = (Parser/get_index)
    ask (BP/check_repeated_ctr_fields fields name ini_idx end_idx)
    ret #Ctr{name type_name type fields} :: Ctr
  } else do Parser {
    ask name    = (BP/parse_name "datatype constructor")
    let name    = (String/concat [type_name "/" name])
    let type    = #Ctr{type_name (List/map _ Type type_vars 位x #Var{x})} :: Type
    ask end_idx = (Parser/get_index)
    ask (BP/check_repeated_ctr_fields [] name ini_idx end_idx)
    ret #Ctr{name type_name type []} :: Ctr
  }
}

// Parses a single field in a constructor definition.
./parse_field : (Parser CtrField)
| = do Parser {
  ask _           = (BP/skp)
  ask rec         = (BP/try_consume "~")
  ask _           = (BP/skp)
  ask has_parens  = (BP/try_consume "(")
  if has_parens do Parser {
    ask _        = (BP/skp)
    ask nam      = (BP/parse_name "datatype constructor field")
    ask _        = (BP/skp)
    ask has_type = (BP/try_consume ":")
    ask typ      = if has_type do Parser {
      ask (BP/skp)
      BP/Fun/parse_type_term
    } else do Parser {
      ret #Any :: Type
    }
    ask _        = (BP/skp)
    ask _        = (BP/consume ")")
    ret #CtrField{nam rec typ} :: CtrField
  } else do Parser {
    ask nam      = (BP/parse_name "datatype constructor field")
    ret #CtrField{nam rec #Any} :: CtrField
  }
}
