use Bend/Fun/Adt as Adt
use Bend/Fun/Ctr as Ctr
use Bend/Fun/CtrField as CtrField
use Bend/Fun/Type as Type
use Bend/Parser as BP
use Bend/Source as Source

// Parses a Fun syntax ADT definition.
// = The parsed ADT and the list of ADT constructors.
Bend/Parser/Fun/parse_adt : (Parser (Pair Adt (List Ctr)))
| = do Parser {
  ask _           = BP/skip_trivia
  ask ini_idx     = Parser/get_index
  ask _           = (BP/parse_keyword "type")
  ask (nam, vars) = parse_name_and_vars
  ask ctrs        = (parse_ctrs nam vars)
  ask end_idx     = Parser/get_index
  let src         = (Source/from_file_span ini_idx end_idx)
  let adt         = #Adt{nam vars (List/map _ _ ctrs Ctr/get_nam) src} :: Adt
  ret (adt, ctrs) :: (_ & _)
}

// Parses the name and type vars part of the ADT definition.
// = The ADT name and type variables.
parse_name_and_vars : (Parser (Pair String (List String)))
| = do Parser {
  ask has_parens = (BP/try_consume "(")
  if has_parens do Parser {
    ask _    = (BP/skip_trivia)
    ask name = (BP/parse_name "datatype")
    ask vars = (BP/list_like _ (BP/parse_name "type variable") "" ")" "" #False 0)
    ask _    = (BP/consume "=")
    ret (name, vars) :: (_ & _)
  } else do Parser {
    ask name = (BP/parse_name "datatype")
    ask vars = (BP/list_like _ (BP/parse_name "type variable") "" "=" "" #False 0)
    ret (name, vars) :: (_ & _)
  }
}

// Parses a single field in a constructor definition.
parse_field : (Parser CtrField)
| = do Parser {
  ask _           = (BP/skip_trivia)
  ask rec         = (BP/try_consume "~")
  ask has_parens  = (BP/try_consume "(")
  if has_parens do Parser {
    ask nam       = (BP/parse_name "datatype constructor field")
    ask has_type  = (BP/try_consume ":")
    ask typ = if has_type {
      BP/Fun/parse_type_term
    } else do Parser {
      ret #Any :: Type
    }
    ask _   = (BP/consume ")")
    ret #CtrField{nam rec typ} :: CtrField
  } else do Parser {
    ask nam = (BP/parse_name "datatype constructor field")
    ret #CtrField{nam rec #Any} :: CtrField
  }
}

// Parses a single constructor in an ADT definition.
parse_ctr : String -> (List String) -> (Parser Ctr)
| type_name type_vars = do Parser {
  // TODO: Check for repeated field names
  ask _          = (BP/skip_trivia)
  ask has_parens = (BP/try_consume "(")
  ask _          = (BP/skip_trivia)
  if has_parens do Parser {
    ask name     = (BP/parse_name "datatype constructor")
    let name     = (String/concat [type_name "/" name])
    ask fields   = (BP/list_like _ parse_field "" ")" "" #False 0)
    let type     = (List/foldr _ (List/map _ _ fields CtrField/get_typ) _
                    #Ctr{type_name (List/map _ Type type_vars 位x #Var{x})} :: Type
                    位l 位r #Arr{l r})
    ret #Ctr{name type_name type fields} :: Ctr
  } else do Parser {
    ask name    = (BP/parse_name "datatype constructor")
    let name    = (String/concat [type_name "/" name])
    let type    = #Ctr{type_name (List/map _ Type type_vars 位x #Var{x})} :: Type
    ret #Ctr{name type_name type []} :: Ctr
  }
}

// Parses the constructors part of an ADT definition.
// - type_name: The name of the ADT being defined.
// - type_vars: The type variables of the ADT being defined.
// = A list of constructors.
parse_ctrs : String -> (List String) -> (Parser (List Ctr))
| type_name type_vars = do Parser {
  // TODO: Check that only previously defined vars occur in the constructors.
  //       This probably needs to be done later, after we have the full book.
  ask head = (parse_ctr type_name type_vars)
  ask many = (BP/try_consume "|")
  ask tail = if many do Parser {
    (BP/sep_by _ (parse_ctr type_name type_vars) "|" 0)
  } else do Parser {
    ret [] :: (List _)
  }
  ret (head ;; tail) :: (List _)
}
