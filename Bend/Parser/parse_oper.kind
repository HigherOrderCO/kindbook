use Bend/Fun/Op as Op
use Bend/Parser as BP

// Parses a Bend numeric operator.
// = The parsed operator.
BP/parse_oper : (Parser Op)
= (BP/first_with_guard _ [
    ((BP/try_consume "+") , (Parser/pure _ #Add))
    ((BP/try_consume "-") , (Parser/pure _ #Sub))
    ((BP/try_consume "**"), (Parser/pure _ #Pow))
    ((BP/try_consume "*") , (Parser/pure _ #Mul))
    ((BP/try_consume "/") , (Parser/pure _ #Div))
    ((BP/try_consume "%") , (Parser/pure _ #Rem))
    ((BP/try_consume "<<"), (Parser/pure _ #Shl))
    ((BP/try_consume ">>"), (Parser/pure _ #Shr))
    ((BP/try_consume "<="), (Parser/pure _ #Lte))
    ((BP/try_consume ">="), (Parser/pure _ #Gte))
    ((BP/try_consume "<") , (Parser/pure _ #Ltn))
    ((BP/try_consume ">") , (Parser/pure _ #Gtn))
    ((BP/try_consume "=="), (Parser/pure _ #Eql))
    ((BP/try_consume "!="), (Parser/pure _ #Neq))
    ((BP/try_consume "&") , (Parser/pure _ #And))
    ((BP/try_consume "|") , (Parser/pure _ #Or))
    ((BP/try_consume "^") , (Parser/pure _ #Xor))
  ] (Parser/fail _ "Expected operator"))

#test: ((BP/parse_oper #State{"+ 1"     0})) == (#Done{#Reply{#State{" 1" 1} #Add}})
#test: ((BP/parse_oper #State{"** 2"    0})) == (#Done{#Reply{#State{" 2" 2} #Pow}})
#test: ((BP/parse_oper #State{"<= 3"    0})) == (#Done{#Reply{#State{" 3" 2} #Lte}})
#test: ((BP/parse_oper #State{"!= 4"    0})) == (#Done{#Reply{#State{" 4" 2} #Neq}})
#test: ((BP/parse_oper #State{"^ 5"     0})) == (#Done{#Reply{#State{" 5" 1} #Xor}})
#test: ((BP/parse_oper #State{"invalid" 0})) == (#Fail{#Error{0 "Expected operator"}})
