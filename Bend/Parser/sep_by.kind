use Bend/Parser as BP

// Parses a list of elements separated by a specified separator.
// Accepts an optional trailing separator.
// - A      : Element type.
// - el     : Parser for the elements.
// - sep    : String separator.
// - min_els: Minimum number of elements required.
// = A parser that produces a list of parsed elements.
BP/sep_by : ∀(A: *) (Parser A) -> String -> U64 -> (Parser (List A))
| A el sep min_els = do Parser {
  ask els = (BP/sep_by/go A el sep min_els [])
  ret (List/reverse A els)
}

// Auxiliary function for sep_by.
BP/sep_by/go : ∀(A: *) (Parser A) -> String -> U64 -> (List A) -> (Parser (List A))
| A el sep 2+n acc = do Parser {
  ask (BP/skp)
  ask val = el
  ask (BP/skp)
  ask (Parser/consume sep)
  (BP/sep_by/go A el sep (+ n 1) #Cons{val acc})
}
| A el sep 1 acc = do Parser {
  ask (BP/skp)
  ask val = el
  ask res = (Parser/alternative (List A)
  (do Parser {
      ask (BP/skp)
      ask (Parser/consume sep)
      (BP/sep_by/go A el sep 0 #Cons{val acc})
    })
    (do Parser {
      ask (BP/skp)
      ask (BP/try_consume sep)
      ret #Cons{val acc}
    }))
  ret res
}
| A el sep 0 acc = do Parser {
  ask (BP/skp)
  (Parser/alternative (List A)
  (do Parser {
    ask val = el
    ask res = (Parser/alternative (List A)
    (do Parser {
          ask (BP/skp)
          ask (Parser/consume sep)
          (BP/sep_by/go A el sep 0 #Cons{val acc})
        })
        (do Parser {
          ask (BP/skp)
          ask consumed = (BP/try_consume sep)
          ret #Cons{val acc}
        }))
      ret res
    })
    (Parser/pure (List A) acc)
  )
}

#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{""                0}) == (#Done{#Reply{#State{""  0} []}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{","               0}) == (#Done{#Reply{#State{"," 0} []}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo"             0}) == (#Done{#Reply{#State{""  3} ["foo"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo,"            0}) == (#Done{#Reply{#State{""  4} ["foo"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo,bar,baz"     0}) == (#Done{#Reply{#State{""  11} ["foo" "bar" "baz"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo,bar,baz,"    0}) == (#Done{#Reply{#State{""  12} ["foo" "bar" "baz"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo , bar , baz" 0}) == (#Done{#Reply{#State{""  15} ["foo" "bar" "baz"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 0) #State{"foo,,bar,,,baz"  0}) == (#Done{#Reply{#State{",bar,,,baz" 4} ["foo"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 2) #State{"foo,bar"         0}) == (#Done{#Reply{#State{"" 7} ["foo" "bar"]}})
#test: ((BP/sep_by String (BP/parse_var_name) "," 2) #State{"foo"             0}) == (#Fail{#Error{3 "Expected ,"}})
#test: ((BP/sep_by String (BP/parse_var_name) ";" 0) #State{"foo;bar;baz"     0}) == (#Done{#Reply{#State{"" 11} ["foo" "bar" "baz"]}})
