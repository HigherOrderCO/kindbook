use Bend/Parser/Imp/parse_type_expr as .
use Bend/Parser as BP
use Bend/Fun/Type as Type

// Parses a type expression, returning the type and the type variables.
Bend/Parser/Imp/parse_type_expr : Bool -> (Parser Type)
| inline = do Parser {
  ask if inline { BP/skip_trivia_inline } else { BP/skip_trivia }
  ask ini_idx = (Parser/get_index)
  ask typ     = (./parse_primary)
  ask typ     = (./parse_suffix inline typ)
  ask end_idx = Parser/get_index
  ret typ
}

./parse_primary : (Parser Type)
| =
  let starts_with_name = do Parser {
    ask c = (Parser/peek_one)
    ret (Maybe/fold _ c Bool #False BP/is_name_char)
  }
  (BP/first_with_guard _ [
    ((BP/starts_with_keyword "Any") , ./parse_any)
    ((BP/starts_with_keyword "None"), ./parse_none)
    ((BP/starts_with_keyword "_")   , ./parse_hole)
    ((BP/starts_with_keyword "u24") , ./parse_u24)
    ((BP/starts_with_keyword "i24") , ./parse_i24)
    ((BP/starts_with_keyword "f24") , ./parse_f24)
    ((Parser/starts_with "(")       , ./parse_parens)
    ((starts_with_name)             , ./parse_var_or_ctr)
  ] (Parser/fail _ "Expected type expression"))

./parse_suffix : Bool -> Type -> (Parser Type)
| inline head = do Parser {
  ask if inline { BP/skip_trivia_inline } else { BP/skip_trivia }
  (BP/first_with_guard _ [
    ((Parser/starts_with ",") , (./parse_tup inline head))
    ((Parser/starts_with "->"), (./parse_arr inline head))
  ] (Parser/pure _ head))
}

./parse_parens : (Parser Type)
| = do Parser {
  ask _   = (BP/consume "(")
  ask typ = (BP/Imp/parse_type_expr #False)
  ask _   = (BP/consume ")")
  ret typ
}

./parse_any : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "Any")
  ret #Any
}

./parse_none : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "None")
  ret #Non
}

./parse_hole : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "_")
  ret #Hol
}

./parse_u24 : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "u24")
  ret #U24
}

./parse_i24 : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "i24")
  ret #I24
}

./parse_f24 : (Parser Type)
| = do Parser {
  ask _ = (BP/parse_keyword "f24")
  ret #F24
}

./parse_var_or_ctr : (Parser Type)
| = do Parser {
  ask name  = (BP/parse_var_name)
  ask _     = (BP/skip_trivia_inline)
  ask paren = (Parser/starts_with "(")
  if paren do Parser {
    ask args = (BP/list_like _ ./parse_primary "(" ")" "," #True 0)
    ret #Ctr{name args}
  } else do Parser {
    ret #Var{name}
  }
}

./parse_arr : Bool -> Type -> (Parser Type)
| inline fst = do Parser {
  ask _   = (BP/consume "->")
  ask snd = (BP/Imp/parse_type_expr inline)
  ret #Arr{fst snd}
}

./parse_tup : Bool -> Type -> (Parser Type)
| inline head = do Parser {
  ask _    = (BP/consume ",")
  ask tail = (BP/Imp/parse_type_expr inline)
  match tail {
    #Tup{tail}: (Parser/pure _ #Tup{head;;tail})
    _         : (Parser/pure _ #Tup{[head tail]})
  }
}

#test: (BP/Imp/parse_type_expr #True (Parser/new_state "Nat")) == #Done{#Reply{#State{"" 3} #Var{"Nat"}}}
#test: (BP/Imp/parse_type_expr #True (Parser/new_state "(Nat)")) == #Done{#Reply{#State{"" 5} #Var{"Nat"}}}
#test: (BP/Imp/parse_type_expr #True (Parser/new_state "\nNat")) == #Fail{#Error{0 "Expected type expression"}}
#test: (BP/Imp/parse_type_expr #False (Parser/new_state "\nNat")) == #Done{#Reply{#State{"" 4} #Var{"Nat"}}}
#test: (BP/Imp/parse_type_expr #True (Parser/new_state "Nat,Nat")) == #Done{#Reply{#State{"" 7} #Tup{[#Var{"Nat"} #Var{"Nat"}]}}}
#test: (BP/Imp/parse_type_expr #True (Parser/new_state "Nat,\nNat")) == #Done{#Reply{#State{"" 7} #Tup{[#Var{"Nat"} #Var{"Nat"}]}}}
#test: (BP/Imp/parse_type_expr #False (Parser/new_state "Nat,\nNat")) == #Done{#Reply{#State{"" 8} #Tup{[#Var{"Nat"} #Var{"Nat"}]}}}
#test: (BP/Imp/parse_type_expr #True (Parser/new_state "Pair(\nNat, \nBool)")) == #Done{#Reply{#State{"" 17} #Ctr{"Pair" [#Var{"Nat"} #Var{"Bool"}]}}}
