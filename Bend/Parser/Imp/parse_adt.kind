use Bend/Parser as BP
use Bend/Fun/Adt as Adt
use Bend/Fun/Ctr as Ctr
use Bend/Fun/CtrField as CtrField
use Bend/Fun/Type as Type

Bend/Parser/Imp/parse_adt : U64 -> (Parser (U64 & Adt & (List Ctr)))
| indent = do Parser {
  ask if (U64/eq indent 0) {
    (Parser/fail _ (String/concat
      ["Indentation error. Types defined with 'type' must be at the start of the line."]))
  } else do Parser { ret 0 }
  
  ask ini_idx = (Parser/get_index)
  ask _       = (BP/parse_keyword "type")
  ask (BP/skp_inline)

  ask name   = (BP/parse_name "data type")
  ask BP/skp_inline

  // Parse type variables
  ask paren  = (Parser/starts_with "(")
  ask vars   = if paren {
    (BP/list_like _ (BP/parse_name "type variable") "(" ")" "," #True 0)
  } else do Parser {
    ret []
  }
  ask BP/skp_inline

  ask _      = (Parser/consume ":")
  ask (BP/consume_new_line)
  let indent = (+ indent 2)
  ask (BP/consume_indent indent)

  ask (nxt_indent, ctrs) = (./parse_ctrs name vars indent indent [])
  ask end_idx = (Parser/get_index)
  let src     = (Bend/Source/from_file_span ini_idx end_idx)
  let adt     = #Adt { name vars (List/map _ _ ctrs Ctr/get_nam) src } :: Adt
  ret (nxt_indent, adt, ctrs)
}

./parse_ctrs : String -> (List String) -> U64 -> U64 -> (List Ctr) -> (Parser U64 & (List Ctr))
| adt vars indent nxt_indent acc with (== indent nxt_indent)
. | 0 = do Parser {
  ret (nxt_indent, acc)
}
. | _ = do Parser {
  ask ctr = (./parse_ctr adt vars)
  ask eof = (Parser/is_eof)
  ask if (Bool/not eof) do Parser {
    (BP/consume_new_line)
  } else do Parser { ret 0 }
  ask nxt_indent = (BP/skp_newlines)
  (./parse_ctrs adt vars indent nxt_indent (ctr;;acc))
}

./parse_ctr : String -> (List String) -> (Parser Ctr)
| adt vars = do Parser {
  ask ini_idx = (Parser/get_index)
  ask name    = (BP/parse_top_level_name)
  let name    = (String/concat [adt "/" name])
  ask BP/skp_inline

  ask fields  = (Parser/starts_with "{")
  ask fields  = if fields {
    (BP/list_like _ BP/Imp/parse_ctr_field "{" "}" "," #True 0)
  } else do Parser { ret [] }
  let fld_typ = (List/map _ _ fields CtrField/get_typ)
  ask end_idx = (Parser/get_index)
  ask (BP/check_repeated_ctr_fields fields name ini_idx end_idx)

  let typ     = #Ctr{name (List/map _ _ vars λx #Var{x})} :: Type
  let typ     = (List/foldr _ fld_typ _ typ (λfield λacc #Arr{field acc}))
  let ctr     = #Ctr { name adt typ fields } :: Ctr
  ret ctr
}
