// Desugars 'fold' expressions in a Book.
// - book: The Book to desugar.
// = A new Book with all 'fold' expressions desugared, or an error message.
Bend/Transform/desugar-fold : Bend/Fun/Book -> (Bend Bend/Fun/Book)
| book = do Bend {
  let defs = (BinMap/values (Bend/Fun/Book/defs book))
  ask defs = (desugar-defs defs)
  let defs = (List/map (λdef (Pair (String/hash (Bend/Fun/FnDef/name def)) def)) defs)
  #Done{(Bend/Fun/Book/set-defs book (BinMap/from-list defs))}
}

// Desugars 'fold' expressions in a term.
// - def: The function definition the term is in.
// - fresh: The fresh name count.
// - term: The term to desugar.
// = The desugared term, the lifted folds and the fresh name count.
//   Doesn't desugar inside the folds themselves.
desugar-term : Bend/Fun/FnDef -> U64 -> Bend/Fun/Term -> (Bend (Pair Bend/Fun/Term (Pair (List Bend/Fun/FnDef) U64)))
| def fresh #Fold{bnd arg with_bnd with_arg arms} = do Bend {
  if (Bend/Fun/Term/has-unscoped-diff term)
    then #Fail{"Can't have non self-contained unscoped variables in a 'fold'"}
    else #Done{Unit/new}

  let new_nam = (String/append (Bend/Fun/FnDef/name def) (String/append "__fold" (U64/show fresh)))
  let fresh = (+ fresh 1)

  // Gather the free variables
  // They will be implicitly captured by the new function
  let fvs = (List/map (λrule 
    let #MatchRule{_ bnds body} = rule
    let fvs = (Bend/Fun/Term/free-vars body)
    let is_free = (λx (Bool/not (List/contains x (List/concat-maybes bnds))))
    (List/filter is_free fvs)) arms)
  let fvs = (List/filter (λx (Bool/not (List/contains x (List/concat-maybes #Cons{bnd with_bnd})))) (List/concat fvs))

  // Transform the recursive fields into aliases to recursive calls to the fold
  ask arms = (List/mmap (λrule do Bend {
    let #MatchRule{nam bnds body} = rule
    ask nam = (Maybe/to-result _ _ nam "fold with no ctr")
    ask ctr = (Bend/Fun/Book/get-ctr book nam)
    let rec = (List/map Bend/Fun/Adt/CtrField/rec (Bend/Fun/Adt/Ctr/fld ctr))
    let bnds = (List/filter-map (λpair 
      let #Pair{bnd rec} = pair
      match rec {
        #True: bnd
        #False: #None
      }) (List/zip bnds rec))
    let body = (List/foldr (λbnd bod 
      let val = (Bend/Fun/Term/foldl-app #Ref{new_nam} (List/map #Var #Cons{bnd fvs}))
      #Use{#Some{bnd} val bod}) body bnds)
    #Done{#MatchRule{#Some{nam} bnds body}}
  }) arms)

  // Create the new function
  let var = "%x"
  let bod = #Mat{#None #Var{var} with_bnd (List/map Bend/Fun/Term/var-or-era with_bnd) arms}
  let bod = (Bend/Fun/Term/foldr-lam bod with_bnd)
  let bod = (Bend/Fun/Term/foldr-lam bod (List/map #Some #Cons{var fvs}))
  let def = (Bend/Fun/FnDef/new-gen new_nam #Cons{#Rule{#Nil bod} #Nil} (Bend/Fun/FnDef/src def) (Bend/Fun/FnDef/check def))

  // Substitute the fold by a call to the new function
  let term = (Bend/Fun/Term/foldl-app #Ref{new_nam} #Cons{arg (List/map #Var fvs)})
  let term = (Bend/Fun/Term/foldl-app #Ref{new_nam} with_arg)
  #Done{#Pair{term #Pair{#Cons{def #Nil} fresh}}}
}

| def fresh term = do Bend {
  (Bend/Fun/Term/mmap-children-with
    (λ_ child #Pair{defs fresh} do Bend {
      ask #Pair{child #Pair{new_defs fresh}} = (desugar-term def fresh child)
      #Done{#Pair{child #Pair{(List/append new_defs defs) fresh}}}
    })
    term #Pair{#Nil fresh})
}

// Desugars 'fold' expressions in a list of rules.
desugar-rules : Bend/Fun/FnDef -> U64 -> (List Bend/Fun/Rule) -> (Bend (Pair (List Bend/Fun/Rule) (Pair (List Bend/Fun/FnDef) U64)))
| def fresh #Nil = do Bend {
  #Done{#Pair{#Nil #Pair{#Nil fresh}}}
}
| def fresh #Cons{rule rules} = do Bend {
  ask #Pair{rules #Pair{defs fresh}}     = (desugar-rules def fresh rules)
  ask #Pair{body #Pair{new_defs fresh}}  = (desugar-term def fresh (Bend/Fun/Rule/body rule))
  #Done{#Pair{#Cons{(Bend/Fun/Rule/set-body rule body) rules} #Pair{(List/append new_defs defs) fresh}}}
}

// Desugars 'fold' expressions in a list of function definitions.
desugar-defs : (List Bend/Fun/FnDef) -> (Bend (List Bend/Fun/FnDef))
| #Nil = #Done{#Nil}
| #Cons{def defs} = do Bend {
  ask #Pair{rules #Pair{new_defs _}} = (desugar-rules def 0 (Bend/Fun/FnDef/rules def))
  ask defs = (desugar-defs (List/append new_defs defs))
  #Done{#Cons{(Bend/Fun/FnDef/set-rules def rules) defs}}
}
