// Creates a new name by appending the use count to the original name.
// If the use count is 1, it returns the original name.
dup-name : String -> U64 -> String
| name uses = if (U64/eq uses 1) 
  then name 
  else (String/append name (String/append "_" (U64/show uses)))

// Retrieves the number of uses for a given variable name from the BinMap.
// Returns 0 if the variable is not found or if the name is None.
get-var-uses : Maybe String -> BinMap U64 -> U64
| #None _ = 0
| #Some{name} var_uses = 
  match (BinMap/get var_uses (String/hash name)) {
    #Some{count}: count
    #None: 0
  }

// Creates a duplicate pattern for variables used multiple times.
// The pattern is a Fan of Dup kind with variables named name_1, name_2, etc.
duplicate-pat : String -> U64 -> Bend/Fun/Pattern
| name uses = 
  #Fan{Bend/Fun/FanKind/Dup (List/map (λi #Var{#Some{(dup-name name i)}}) (U64/range 1 (+ uses 1)))}

// Main function to linearize variables in a term.
// It transforms the term to ensure each variable is used at most once.
linearize-vars-term : Bend/Fun/Term -> BinMap U64 -> (Pair Bend/Fun/Term (BinMap U64))

// Let terms with just a variable get inlined
| #Let{#Var{#Some{nam}} val nxt} var_uses = 
  let #Pair{nxt var_uses} = (linearize-vars-term nxt var_uses)
  let uses = (get-var-uses #Some{nam} var_uses)
  let #Pair{val var_uses} = (linearize-vars-term val var_uses)
  let term = match uses {
    0: #Let{#Var{#None} val nxt}
    1: (Bend/Transform/subst nam val nxt)
    _: #Let{(duplicate-pat nam uses) val nxt}
  }
  #Pair{term var_uses}

// Count var uses and update the name to the duplication
| #Var{#Some{nam}} var_uses = 
  let count = (get-var-uses #Some{nam} var_uses)
  let new_count = (+ count 1)
  let var_uses = (BinMap/set var_uses (String/hash nam) new_count)
  let term = #Var{#Some{(dup-name nam new_count)}}
  #Pair{term var_uses}

| term var_uses = 
  // linearize the children
  let #Pair{term var_uses} = (Bend/Fun/Term/map-children-with (λ_ linearize-vars-term) term var_uses)
  // erase unused bindings
  let term = (Bend/Fun/Term/map-child-binds (λbind _ (erase-unused-bind bind var_uses)) term)
  // add duplications of bindings
  let term = (duplicate-term term var_uses)
  #Pair{term var_uses}

// Erases bindings that are not used (count is 0)
erase-unused-bind : Maybe String -> BinMap U64 -> Maybe String
| bind var_uses = if (U64/eq (get-var-uses bind var_uses) 0) then #None else bind

// Adds duplication bindings for variables used multiple times
duplicate-binds : List String -> Bend/Fun/Term -> BinMap U64 -> Bend/Fun/Term
| bnd nxt var_uses = 
  (List/foldr (λbnd nxt 
    let uses = (get-var-uses #Some{bnd} var_uses)
    if (U64/gt uses 1)
      then #Let{(duplicate-pat bnd uses) #Var{bnd} nxt}
      else nxt) nxt bnd)

// Applies duplication to specific term types (Lam and Let)
duplicate-term : Bend/Fun/Term -> BinMap U64 -> Bend/Fun/Term
| #Lam{pat bod} var_uses = 
  let bod = (duplicate-binds (Bend/Fun/Pattern/binds pat) bod var_uses)
  #Lam{pat bod}
| #Let{pat val nxt} var_uses = 
  let nxt = (duplicate_binds (Bend/Fun/Pattern/binds pat) nxt var_uses)
  #Let{pat val nxt}
| term var_uses = term

// Applies linearize-vars-term to all functions in the book
Bend/Transform/linearize-vars : Bend/Fun/Book -> Bend/Fun/Book
| #Book{defs adts ctrs} = 
  let map_body = (λbody let #Pair{term _} = (linearize-vars-term body BinMap/empty) term)
  let map_rule = (λrule (Bend/Fun/Rule/set-body rule (map_body (Bend/Fun/Rule/body rule))))
  let map_def  = (λdef (Bend/Fun/FnDef/set-rules def (List/map map_rule (Bend/Fun/FnDef/rules def))))
  let defs     = (BinMap/to-list defs)
  let defs     = (List/map (λpair let #Pair{key def} = pair #Pair{key (map_def def)}) defs)
  #Book{(BinMap/from-list defs) adts ctrs}
