// Generate a new unique name and increment the counter
fresh : U64 -> (Pair String U64)
| count = #Pair{(Bend/nat-to-name count) (+ count 1)}

push-scope : (List (Maybe String)) -> U64 -> (BinMap (List String)) -> (Pair U64 (BinMap (List String)))
| #Cons{#Some{name} xs} count scope = 
  let #Pair{nam count} = (fresh count)
  let nams = (Maybe/fold #Nil (λx x) (BinMap/get scope (String/hash name)))
  let scope = (BinMap/set scope (String/hash name) #Cons{nam nams})
  (push-scope xs count scope)
| #Cons{#None xs} count scope = (push-scope xs count scope)
| #Nil count scope = #Pair{count scope}

push-pattern : Bend/Fun/Pattern -> U64 -> (BinMap (List String)) -> (Pair U64 (BinMap (List String)))
| pat gen scope = (push-scope (List/map #Some (Bend/Fun/Pattern/binds pat)) gen scope)

pop-scope : (Maybe String) -> (BinMap (List String)) -> (Pair (Maybe String) (BinMap (List String)))
| #Some{nam} scope = 
  match (BinMap/get scope (String/hash nam)) {
    #Some{#Cons{nam nams}}: #Pair{#Some{nam} (BinMap/set scope (String/hash nam) nams)}
    _: #Pair{#Some{nam} scope}  // This case should be unreachable
  }
| #None scope = #Pair{#None scope}

pop-list : (List (Maybe String)) -> (BinMap (List String)) -> (Pair (List (Maybe String)) (BinMap (List String)))
| bnds scope = 
  (List/foldr (λbnd pair 
    let #Pair{bnds scope} = pair
    let #Pair{bnd scope} = (pop-scope bnd scope)
    #Pair{#Cons{bnd bnds} scope}) #Pair{#Nil scope} bnds)

pop-pattern : Bend/Fun/Pattern -> (BinMap (List String)) -> (Pair Bend/Fun/Pattern (BinMap (List String)))
| #Var{#Some{name}} scope = 
  match (BinMap/get scope (String/hash name)) {
    #Some{#Cons{nam nams}}: #Pair{#Var{#Some{nam}} (BinMap/set scope (String/hash name) nams)}
    _: #Pair{#Var{#Some{name}} scope}
  }
| #Var{#None} scope = #Pair{#Var{#None} scope}
| #Fan{kind pats} scope = 
  let #Pair{pats scope} = (List/foldr (λpat pair 
    let #Pair{pats sc} = pair
    let #Pair{pat sc} = (pop-pattern pat sc)
    #Pair{#Cons{pat pats} sc}) #Pair{#Nil scope} pats)
  #Pair{#Fan{kind pats} scope}
| #Ctr{name pats} scope = 
  let #Pair{pats scope} = (List/foldr (λpat pair 
    let #Pair{pats sc} = pair
    let #Pair{pat sc} = (pop-pattern pat sc)
    #Pair{#Cons{pat pats} sc}) #Pair{#Nil scope} pats)
  #Pair{#Ctr{name pats} scope}
| #Lst{pats} scope = 
  let #Pair{pats scope} = (List/foldr (λpat pair 
    let #Pair{pats sc} = pair
    let #Pair{pat sc} = (pop-pattern pat sc)
    #Pair{#Cons{pat pats} sc}) #Pair{#Nil scope} pats)
  #Pair{#Lst{pats} scope}
| #Chn{nam} scope = #Pair{#Chn{nam} scope}
| #Num{num} scope = #Pair{#Num{num} scope}
| #Str{str} scope = #Pair{#Str{str} scope}

use-var : String -> (BinMap (List String)) -> String
| nam scope = 
  match (BinMap/get scope (String/hash nam)) {
    #Some{#Cons{nam _}}: nam
    _: nam  // Unbound variable case
  }

// Apply unique names to a term
unique-names-term : U64 -> (BinMap (List String)) -> Bend/Fun/Term -> (Pair Bend/Fun/Term (Pair U64 (BinMap (List String))))
| gen scope #Var{nam} = 
  let nam = (use-var nam scope)
  #Pair{#Var{nam} #Pair{gen scope}}

| gen scope #Mat{bnd arg with_bnd with_arg arms} = 
  let #Pair{arg #Pair{gen scope}} = (unique-names-term gen scope arg)
  let #Pair{with_arg #Pair{gen scope}} = (unique-names-list gen scope with_arg)
  let #Pair{gen scope} = (push-scope #Cons{bnd #Nil} gen scope)
  let #Pair{gen scope} = (push-scope with_bnd gen scope)
  let #Pair{arms #Pair{gen scope}} = (unique-names-match gen scope arms)
  let #Pair{with_bnd scope} = (pop-list with_bnd scope)
  let #Pair{bnd scope} = (pop-scope bnd scope)
  #Pair{#Mat{bnd arg with_bnd with_arg arms} #Pair{gen scope}}

// ... (similar pattern for other term constructors)

// Apply unique names to a list of terms
unique-names-list : U64 -> (BinMap (List String)) -> (List Bend/Fun/Term) -> (Pair (List Bend/Fun/Term) (Pair U64 (BinMap (List String))))
| gen scope #Nil = #Pair{#Nil #Pair{gen scope}}
| gen scope #Cons{t ts} = 
  let #Pair{t #Pair{gen scope}} = (unique-names-term gen scope t)
  let #Pair{ts #Pair{gen scope}} = (unique-names-list gen scope ts)
  #Pair{#Cons{t ts} #Pair{gen scope}}

// Apply unique names to a list of match rules
unique-names-match : U64 -> (BinMap (List String)) -> (List Bend/Fun/MatchRule) -> (Pair (List Bend/Fun/MatchRule) (Pair U64 (BinMap (List String))))
| gen scope #Nil = #Pair{#Nil #Pair{gen scope}}
| gen scope #Cons{arm arms} = 
  let #Pair{gen scope} = (push-scope (Bend/Fun/MatchRule/bnd arm) gen scope)
  let #Pair{bod #Pair{gen scope}} = (unique-names-term gen scope (Bend/Fun/MatchRule/body arm))
  let #Pair{bnd scope} = (pop-list (Bend/Fun/MatchRule/bnd arm) scope)
  let arm = (Bend/Fun/MatchRule/set-body (Bend/Fun/MatchRule/set-bnd arm bnd) bod)
  let #Pair{arms #Pair{gen scope}} = (unique-names-match gen scope arms)
  #Pair{#Cons{arm arms} #Pair{gen scope}}

// Apply unique names to switch cases
unique-names-swt : U64 -> (BinMap (List String)) -> (Maybe String) -> (List Bend/Fun/Term) -> (Pair (Maybe String) (Pair (List Bend/Fun/Term) (Pair U64 (BinMap (List String)))))
| gen scope pred #Nil = #Pair{pred #Pair{#Nil #Pair{gen scope}}}
| gen scope pred #Cons{x #Nil} = 
  let #Pair{gen scope} = (push-scope #Cons{pred #Nil} gen scope)
  let #Pair{x #Pair{gen scope}} = (unique-names-term gen scope x)
  let #Pair{pred scope} = (pop-scope pred scope)
  #Pair{pred #Pair{#Cons{x #Nil} #Pair{gen scope}}}
| gen scope pred #Cons{x xs} = 
  let #Pair{x #Pair{gen scope}} = (unique-names-term gen scope x)
  let #Pair{pred #Pair{xs #Pair{gen scope}}} = (unique-names-swt gen scope pred xs)
  #Pair{pred #Pair{#Cons{x xs} #Pair{gen scope}}}

// Apply unique names to a Book
Bend/Transform/unique-names : Bend/Fun/Book -> Bend/Fun/Book
| #Book{defs adts ctrs} = 
  let defs = (List/foldr (λpair defs 
    let #Pair{key def} = pair
    let def = (Bend/Fun/FnDef/set-rules def (unique-names-rules 0 (Bend/Fun/FnDef/rules def)))
    #Cons{#Pair{key def} defs}) #Nil (BinMap/to-list defs))
  #Book{(BinMap/from-list defs) adts ctrs}

unique-names-rules : U64 -> (List Bend/Fun/Rule) -> (List Bend/Fun/Rule)
| gen #Nil = #Nil
| gen #Cons{#Rule{pats bod} rules} = 
  let scope = BinMap/empty
  let #Pair{gen scope} = (push-scope (List/map #Some (List/concat (List/map Bend/Fun/Pattern/binds pats))) gen scope)
  let #Pair{bod #Pair{gen scope}} = (unique-names-term gen scope bod)
  let #Pair{pats scope} = (List/foldr (λpat pair 
    let #Pair{pats scope} = pair
    let #Pair{pat scope} = (pop-pattern pat scope)
    #Pair{#Cons{pat pats} scope}) #Pair{#Nil scope} pats)
  let rules = (unique-names-rules gen rules)
  #Cons{#Rule{pats bod} rules}
