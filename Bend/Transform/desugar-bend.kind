use Bend/Fun/Book as Book
use Bend/Fun/FnDef as FnDef
use Bend/Fun/Rule as Rule
use Bend/Fun/Term as Term

// Desugars 'bend' expressions in a Book
// - book: The Book to desugar
// = The Book with 'bend' terms lifted to top-level functions, or an error message.
Bend/Transform/desugar-bend : Book -> (Bend Book)
| book = do Bend {
  let defs = (BinMap/values _ (Book/defs book))
  ask defs = (desugar-defs defs)
  let defs = (List/map _ _ (λdef (Pair (String/hash (FnDef/name def)) def)) defs)
  #Done{(Book/set-defs book (BinMap/from-list _ defs))}
}

RECURSIVE_KW : String
| = "fork"

NEW_FN_SEP : String
| = "__bend"

desugar-term : FnDef -> U64 -> Term -> (Bend (Pair Term (Pair (List FnDef) U64)))
| #FnDef{nam typ chk rul src} fresh #Bnd{bnd arg cond step base} = do Bend {
  ask if (Term/has-unscoped-diff term) {
    #Fail{"Can't have non self-contained unscoped variables in a 'bend'"}
  } else {
    #Done{0}
  }

  let name = (String/append (FnDef/name def) (String/append NEW_FN_SEP (U64/show fresh)))
  let fresh = (+ fresh 1)

  // Gather the free variables
  // They will be implicitly captured by the new function
  let fvs = (Term/free-vars step)
  let fvs = (List/filter _ (λx (String/neq RECURSIVE_KW x)) fvs)
  let fvs = (List/append _ (Term/free-vars base) fvs)
  let fvs = (List/append _ (Term/free-vars cond) fvs)
  let fvs = (List/filter _ (λx (Bool/not (List/contains x (List/concat-maybes bnd)))) fvs)

  // Add a substitution of `fork`, a use term with a partially applied recursive call
  let step = #Use{#Some{RECURSIVE_KW}
                 (Term/foldl-app (Term/foldl-app #Ref{name} (List/map #Var fvs)) arg)
                 step}

  // Create the new function
  let body = #Swt{#Some{"_"} cond [] [] #Some{"_-1"} #Cons{base #Cons{step #Nil}}}
  let body = (Term/foldr-lam body bnd)
  let body = (Term/foldr-lam body (List/map #Some fvs))
  let def  = (FnDef/new-gen name 
                                    #Cons{#Rule{[] body} #Nil}
                                    (FnDef/src def)
                                    (FnDef/check def))

  // Substitute the bend by a call to the new function
  let term = (Term/foldl-app #Ref{name} (List/map #Var fvs))
  let term = (Term/foldl-app term arg)
  #Done{#Pair{term #Pair{#Cons{def #Nil} fresh}}}
}

| def fresh term =
  (Term/mmap-children-with 
    (λ_ λchild λ{#Pair{defs fresh}: do Bend {
      ask #Pair{child s} = (desugar-term def fresh child)
      let #Pair{new_defs fresh} = s
      #Done{#Pair{child #Pair{(List/append new_defs defs) fresh}}}
    }})
    term
    #Pair{#Nil fresh}
  )


desugar-rules : FnDef -> U64 -> (List Rule) -> (Bend (Pair (List Rule) (Pair (List FnDef) U64)))
| def fresh #Nil = do Bend {
  #Done{#Pair{#Nil #Pair{#Nil fresh}}}
}
| def fresh #Cons{rule rules} = do Bend {
  ask #Pair{rules s}    = (desugar-rules def fresh rules)
  let #Pair{defs fresh} = s
  ask #Pair{body s} = (desugar-term def 0 (Rule/body rule))
  let #Pair{new_defs fresh} = s
  #Done{#Pair{#Cons{(Rule/set-body rule body) rules} #Pair{(List/append new_defs defs) fresh}}}
}

desugar-defs : (List FnDef) -> (Bend (List FnDef))
| #Nil = do Bend {
  #Done{#Nil}
}
| #Cons{def defs} = do Bend {
  ask #Pair{rules s} = (desugar-rules def 0 (FnDef/rules def))
  let #Pair{new_defs _} = s
  ask defs = (desugar-defs (List/append new_defs defs))
  #Done{#Cons{(FnDef/set-rules def rules) defs}}
}
