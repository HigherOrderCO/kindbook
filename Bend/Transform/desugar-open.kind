// Desugars 'open' expressions in a Book
// - book: The Book to desugar
// = Either the desugared Book or an error message
Bend/Transform/desugar-open : Bend/Fun/Book -> (Bend Bend/Fun/Book)
| book = (Bend/Fun/Book/mmap-rules (desugar-rule book) book)

// Desugars 'open' expressions in a term
// - book: The Book to desugar
// - term: The term to desugar
// = Either the desugared term or an error message
desugar-term : Bend/Fun/Book -> Bend/Fun/Term -> (Bend Bend/Fun/Term)
| book #Open{typ var bnd bod} = do Bend {
  match (Bend/Fun/Book/get-adt-ctrs book typ) {
    #Done{#Cons{ctr #Nil}}: do Bend {
      ask bod = (desugar-term book bod)
      #Done{#Mat{var (Bend/Fun/Term/var-or-era var) [] [] #Cons{#MatchRule{#Some{(Bend/Fun/Adt/Ctr/nam ctr)} bnd bod} #Nil}}}
    }
    #Done{_}: 
      #Fail{(String/append "Type '" (String/append typ "' of an 'open' doesn't have exactly one constructor"))}
    #Fail{_}:
      #Fail{(String/append "Type '" (String/append typ "' of an 'open' is not defined"))}
  }
}

| book #Def{def nxt} = do Bend {
  ask rules = (List/mmap (desugar-rule book) (Bend/Fun/FnDef/rules def))
  ask nxt = (desugar-term book nxt)
  #Done{#Def{(Bend/Fun/FnDef/set-rules def rules) nxt}}
}

| book term = do Bend {
  (Bend/Fun/Term/mmap-children (Î»_ (desugar-term book)) term)
}

desugar-rule : Bend/Fun/Book -> Bend/Fun/Rule -> (Bend Bend/Fun/Rule)
| book rule = do Bend {
  ask body = (desugar-term book (Bend/Fun/Rule/body rule))
  #Done{(Bend/Fun/Rule/set-body rule body)}
}
