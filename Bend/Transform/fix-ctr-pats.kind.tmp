// Resolves constructor patterns
Bend/Transform/fix-ctr-pats : Bend/Fun/Book -> (Bend Bend/Fun/Book)
| book = do Bend {
  ask defs = (List/mmap (λpair do Bend {
    let #Pair{key def} = pair
    ask def = (fix-term book #Def{def #Era})
    match def {
      #Def{def _}: #Done{#Pair{key def}}
      _: #Fail{"Unexpected term type after fixing match defs"}
    }
  }) (BinMap/to-list (Bend/Fun/Book/defs book)))
  #Done{(Bend/Fun/Book/set-defs book (BinMap/from-list defs))}
}

resolve-pat : Bend/Fun/Book -> Bend/Fun/Pattern -> Bend/Fun/Pattern
| book #Var{#Some{nam}} = 
  if (Result/is-done (Bend/Fun/Book/get-ctr book nam))
    then #Ctr{nam #Nil}
    else #Var{#Some{nam}}
| book pat = (Bend/Fun/Pattern/map-children (resolve-pat book) pat)

check-good-ctr : Bend/Fun/Book -> Bend/Fun/Pattern -> (Bend Unit)
| book #Ctr{nam args} = do Bend {
  ask ctr = (Result/fold #Done (λ_ #Fail{(String/append "Unbound constructor '" (String/append nam "' in pattern matching rule."))}) (Bend/Fun/Book/get-ctr book nam))
  let expected_arity = (List/length (Bend/Fun/Adt/Ctr/fld ctr))
  let found_arity = (List/length args)
  if (U64/neq expected_arity found_arity)
    then #Fail{(String/append "Incorrect arity for constructor '" 
               (String/append nam 
               (String/append "' of type '" 
               (String/append (Bend/Fun/Adt/Ctr/adt ctr) 
               (String/append "' in pattern matching rule. Expected " 
               (String/append (U64/show expected_arity) 
               (String/append " fields, found " 
               (String/append (U64/show found_arity) ""))))))))}
    else #Done{Unit/new}
}
| book pat = do Bend {
  ask _ = (List/mmap (check-good-ctr book) (Bend/Fun/Pattern/children pat))
  #Done{Unit/new}
}

fix-pat : Bend/Fun/Book -> Bend/Fun/Pattern -> (Bend Bend/Fun/Pattern)
| book pat = do Bend {
  let pat = (resolve-pat book pat)
  ask _ = (check-good-ctr book pat)
  #Done{pat}
}

fix-term : Bend/Fun/Book -> Bend/Fun/Term -> (Bend Bend/Fun/Term)
| book #Def{def nxt} = do Bend {
  ask rule = (Maybe/to-result _ _ (List/head (Bend/Fun/FnDef/rules def)) "No rules")
  let ari = (List/length (Bend/Fun/Rule/pats rule))
  ask rules = (List/mmap (fix-rule book ari) (Bend/Fun/FnDef/rules def))
  ask nxt = (fix-term book nxt)
  #Done{#Def{(Bend/Fun/FnDef/set-rules def rules) nxt}}
}
| book term = (Bend/Fun/Term/mmap-children (λ_ (fix-term book)) term)

fix-rule : Bend/Fun/Book -> U64 -> Bend/Fun/Rule -> (Bend Bend/Fun/Rule)
| book def_arity #Rule{pats body} = do Bend {
  if (U64/neq def_arity (List/length pats))
    then #Fail{(String/append "Incorrect pattern matching rule arity. Expected " 
               (String/append (U64/show def_arity) 
               (String/append " args, found " 
               (String/append (U64/show (List/length pats)) "."))))}
    else #Done{Unit/new}
  ask pats = (List/mmap (fix-pat book) pats)
  ask body = (fix-term book body)
  #Done{#Rule{pats body}}
}
