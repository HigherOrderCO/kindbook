is_combinator : Bend/Fun/Term -> Bool
| term = (Bool/and (List/is_nil (Bend/Fun/Term/free_vars term))
         (Bool/and (Bool/not (Bend/Fun/Term/has_unscoped_diff term))
                  (Bool/not (Bend/Fun/Term/is_ref term))))

// Creates a new function from the given term.
// The new function is added to the context.
// = Returns a term referencing the new function and the updated context.
float : Bend/Transform/FloatCombinators/Ctx -> Bool -> Bend/Fun/Term -> (Pair Bend/Fun/Term Bend/Transform/FloatCombinators/Ctx)
| ctx safe term = 
  let nam = (String/append (Bend/Fun/FnDef/name (Bend/Transform/FloatCombinators/Ctx/def ctx)) 
            (String/append "__C" (U64/show (Bend/Transform/FloatCombinators/Ctx/name-gen ctx))))
  let ctx = (Bend/Transform/FloatCombinators/Ctx/set-name-gen ctx (+ (Bend/Transform/FloatCombinators/Ctx/name-gen ctx) 1))
  let def = (Bend/Fun/FnDef/new_gen nam #Cons{#Rule{#Nil term} #Nil} (Bend/Fun/FnDef/src (Bend/Transform/FloatCombinators/Ctx/def ctx)) #True)
  let ctx = (Bend/Transform/FloatCombinators/Ctx/set-combinators ctx (BinMap/set (Bend/Transform/FloatCombinators/Ctx/combinators ctx) (String/hash nam) #Pair{safe def}))
  #Pair{#Ref{nam} ctx}

pattern-size : Bend/Fun/Pattern -> U64
| #Fan{_ pats} = (+ (- (List/length pats) 1) (List/sum (List/map pattern-size pats)))
| #Var{_} = 0
| #Chn{_} = 0
| _ = 0  // Should be unreachable

base-size : Bend/Fun/Term -> U64
| #Let{pat _ _}        = (pattern-size pat)
| #Fan{_ els}          = (- (List/length els) 1)
| #Mat{_ _ _ _ arms}   = (List/length arms)
| #Swt{_ _ _ _ _ arms} = (* 2 (- (List/length arms) 1))
| #Lam{_ _}            = 1
| #App{_ _}            = 1
| #Opr{_ _ _}          = 1
| _                    = 0

term-size : Bend/Fun/Term -> U64
| term = 
  let size_children = (List/map (λpair let #Pair{_ t} = pair (term-size t)) (Bend/Fun/Term/children term))
  (+ (List/sum size_children) (base-size term))

float-term-child : Bool -> Bend/Fun/Term -> (Pair Bend/Transform/FloatCombinators/Ctx U64) -> (Pair Bend/Fun/Term (Pair Bend/Transform/FloatCombinators/Ctx U64))
| par_comb child #Pair{ctx par_size} = 
  let child_safe = (Bend/Transform/FloatCombinators/is_safe ctx #Nil child)
  let child_size = (term-size child)
  let child_comb = (is_combinator child)
  let too_large = if par_comb {
    (U64/gt par_size (Bend/Transform/FloatCombinators/Ctx/max-size ctx))
  } else {
    (U64/gt (Bend/Transform/FloatCombinators/Ctx/def-size ctx) (Bend/Transform/FloatCombinators/Ctx/max-size ctx))
  }
  if (Bool/and child_comb (Bool/and (U64/gt child_size 0) (Bool/or (Bool/not child_safe) too_large))) {
    let ctx = (Bend/Transform/FloatCombinators/Ctx/set-def-size ctx (- (Bend/Transform/FloatCombinators/Ctx/def-size ctx) child_size))
    let par_size = (- par_size child_size)
    let #Pair{child ctx} = (float ctx child_safe child)
    #Pair{child #Pair{ctx par_size}}
  } else {
    #Pair{child #Pair{ctx par_size}}
  }

float-term : Bend/Fun/Term -> Bend/Transform/FloatCombinators/Ctx -> (Pair Bend/Fun/Term Bend/Transform/FloatCombinators/Ctx)
| term ctx = 
  // Float from the bottom up
  let #Pair{term ctx} = (Bend/Transform/FloatCombinators/map-float_children float-term term ctx)
  let par_size = (term-size term)
  let par_comb = (is_combinator term)
  let #Pair{term #Pair{ctx _}} = (Bend/Transform/FloatCombinators/map-float_children (float-term-child par_comb) term #Pair{ctx par_size})
  #Pair{term ctx}

float-combinators-defs : (List Bend/Fun/FnDef) -> (Pair (List Bend/Fun/FnDef) (BinMap (Pair Bool Bend/Fun/FnDef))) -> (Pair (List Bend/Fun/FnDef) (List Bend/Fun/FnDef))
| #Nil #Pair{acc_defs acc_combs} = 
  let acc_combs = (List/map (λx let #Pair{_ #Pair{_ def}} = x def) (BinMap/to-list acc_combs))
  #Pair{acc_defs acc_combs}

| #Cons{def defs} #Pair{acc_defs acc_combs} = 
  match (Bend/Fun/FnDef/rules def) {
    #Cons{rule #Nil}: 
      let ctx = (Bend/Transform/FloatCombinators/Ctx/init-ctx book def max_size acc_combs)
      let #Pair{bod ctx} = (float-term (Bend/Fun/Rule/body rule) ctx)
      let def = (Bend/Fun/FnDef/set_rul def #Cons{(Bend/Fun/Rule/set-body rule bod) #Nil})
      (float-combinators-defs defs #Pair{#Cons{def acc_defs} (Bend/Transform/FloatCombinators/Ctx/combinators ctx)})
    _: 
      let def = (Bend/Fun/FnDef/set_rul def #Cons{#Rule{#Nil #Era} #Nil})
      (float-combinators-defs defs #Pair{#Cons{def acc_defs} acc_combs})
  }

// Floats combinators in a Book
Bend/Transform/FloatCombinators/float-combinators : Bend/Fun/Book -> U64 -> Bend/Fun/Book
| book max_size = 
  // TODO: Don't float the entrypoint function
  let #Pair{keys defs} = (List/unzip (BinMap/to-list (Bend/Fun/Book/defs book)))
  let #Pair{defs combinators} = (float-combinators-defs defs #Pair{#Nil BinMap/empty})
  let defs = (List/map (λdef #Pair{(String/hash (Bend/Fun/FnDef/name def)) def}) (List/append combinators defs))
  (Bend/Fun/Book/set_defs book (BinMap/from_list defs))
