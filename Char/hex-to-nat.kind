use Char/ as C/
use Nat/ as N/
use U32/ as U32/
use Maybe/ as M/
use Bool/ as B/

// Converts a hexadecimal character to its corresponding natural number.
// 1st: The input hexadecimal character
// = Some n if 1st is a valid hexadecimal digit, where n is the corresponding natural number, None otherwise.
C/hex-to-nat
: ∀(code: C/Char)
  (M/Maybe N/Nat)
= λcode
  let is_hex = (C/is-hex-digit code)
  let case_0_9 = (- code 48)
  let case_A_F = (- code 55)
  let case_a_f = (- code 87)
  let value =
    (U32/if U32
      (< code 58)
      case_0_9
      (U32/if U32
        (< code 97)
        case_A_F
        case_a_f))
  (B/if (M/Maybe N/Nat)
    is_hex
    #Some{(U32/to-nat value)}
    #None{})
//TEST//

use Char/ as C/
use Nat/ as N/
use Maybe/ as M/
use Equal/ as E/

// Test: Convert '0' to 0.
T0
: (E/Equal (M/Maybe N/Nat) (C/hex-to-nat '0') #Some{#Zero{}})
= #Refl{}

// Test: Convert 'A' to 10.
T1
: (E/Equal (M/Maybe N/Nat) (C/hex-to-nat 'A') #Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}})
= #Refl{}

// Test: Convert 'f' to 15.
T2
: (E/Equal (M/Maybe N/Nat) (C/hex-to-nat 'f') #Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Invalid hexadecimal character.
T3
: (E/Equal (M/Maybe N/Nat) (C/hex-to-nat 'G') #None{})
= #Refl{}