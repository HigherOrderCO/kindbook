// Removes and returns the first element from a queue.
// - 1st: The type of elements in the queue.
// - 2nd: The queue to dequeue from.
// = A Maybe containing a Pair of the dequeued element and the remaining queue, or None if the queue is empty.
Queue/dequeue
: ∀(A: *)
  ∀(q: (Queue/Queue A))
  (Maybe/Maybe (Pair/Pair A (Queue/Queue A)))
= λA λ{
  #MkQueue:  λ{
		#Nil: λback
			let revb = (List/reverse A back)
			let none = #None{Pair/Pair A (Queue/Queue A)}
			use some = λhead λtail #Some{#Pair{head #MkQueue{tail #Nil{}}}}
			(List/match A (λx (Maybe/Maybe (Pair/Pair A (Queue/Queue A)))) none some revb)
		#Cons: λhead λtail λback #Some{ #Pair{head #MkQueue{tail back}}}
	} 
}
// Test: Dequeue from an empty queue
TEST_0
: ∀(A: *) (Equal/Equal (Maybe/Maybe (Pair/Pair A (Queue/Queue A))) (Queue/dequeue A (#MkQueue{#Nil{} #Nil{}})) (#None{}))
= λA #Refl{}

// Test: Dequeue from a queue with one element in front
TEST_1
: (Equal/Equal (Maybe/Maybe (Pair/Pair U32 (Queue/Queue U32))) (Queue/dequeue U32 (#MkQueue{#Cons{1 #Nil{}} #Nil{}})) (#Some{#Pair{1 #MkQueue{#Nil{} #Nil{}}}}))
= #Refl{}

// Test: Dequeue from a queue with multiple elements in front
TEST_2
: (Equal/Equal (Maybe/Maybe (Pair/Pair U32 (Queue/Queue U32))) (Queue/dequeue U32 (#MkQueue{#Cons{1 #Cons{2 #Cons{3 #Nil{}}}} #Nil{}})) (#Some{#Pair{1 #MkQueue{#Cons{2 #Cons{3 #Nil{}}} #Nil{}}}}))
= #Refl{}

// Test: Dequeue from a queue with elements only in back
TEST_3
: (Equal/Equal (Maybe/Maybe (Pair/Pair U32 (Queue/Queue U32))) (Queue/dequeue U32 (#MkQueue{#Nil{} #Cons{3 #Cons{2 #Cons{1 #Nil{}}}}})) (#Some{#Pair{1 #MkQueue{#Cons{2 #Cons{3 #Nil{}}} #Nil{}}}}))
= #Refl{}

// Test: Dequeue from a queue with elements in both front and back
TEST_4
: (Equal/Equal (Maybe/Maybe (Pair/Pair U32 (Queue/Queue U32))) (Queue/dequeue U32 (#MkQueue{#Cons{1 #Nil{}} #Cons{3 #Cons{2 #Nil{}}}})) (#Some{#Pair{1 #MkQueue{#Nil{} #Cons{3 #Cons{2 #Nil{}}}}}}))
= #Refl{}