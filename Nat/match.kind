// Applies a function to a natural number based on its structure.
// This function allows pattern matching on natural numbers.
// 1st: A type-level function that determines the return type for each case.
// 2nd: The value to return in the zero case.
// 3rd: The function to apply in the successor case.
// 4th: The natural number to match on.
// = The result of matching on the input natural number.
Nat/match
: ∀(P: ∀(x: Nat) *)
  ∀(z: (P #Zero{}))
  ∀(s: ∀(x: Nat) (P #Succ{x}))
  ∀(n: Nat)
  (P n)
= λP λz λs λ{
  #Zero: z
  #Succ: λn.pred (s n.pred)
}
// A simple function that returns a string description of a natural number
Nat/describe
: ∀(n: Nat)
  Bool
= (Nat/match
    λx(Bool)
    #False{}
    λpred #True{}
  )

// Test: Describe of Zero{}
TEST_0
: (Equal Bool (Nat/describe #Zero{}) #False{})
= #Refl{}

// Test: Describe of Succ{Zero}
TEST_1
: (Equal Bool (Nat/describe #Succ{#Zero{}}) #True{})
= #Refl{}

// Test: Describe of Succ{Succ{Zero}}
TEST_2
: (Equal Bool (Nat/describe #Succ{#Succ{#Zero{}}}) #True{})
= #Refl{}

// Test: Describe of Succ{Succ{Succ{Zero}}}
TEST_3
: (Equal Bool (Nat/describe #Succ{#Succ{#Succ{#Zero{}}}}) #True{})
= #Refl{}

// Test: Equality of describe results for different non-zero numbers
TEST_4
: (Equal Bool (Bool/eq (Nat/describe #Succ{#Zero{}}) (Nat/describe #Succ{#Succ{#Zero{}}})) #True{})
= #Refl{}

// Test: Inequality of describe results for zero and non-zero
TEST_5
: (Equal Bool (Bool/eq (Nat/describe #Zero{}) (Nat/describe #Succ{#Zero{}})) #False{})
= #Refl{}