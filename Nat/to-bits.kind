// Converts a natural number to its binary representation.
// 1st: The natural number to convert.
// = The binary representation of the number as Bits.
Nat/to-bits
: ∀(n: Nat)
  Bits
= λ{
  #Zero: #O{#E}
	#Succ: λ{
		#Zero: #I{#E}
		#Succ: λn.pred
			let quotient = (Nat/div #Succ{#Succ{n.pred}} #2)
			let remainder = (Nat/mod #Succ{#Succ{n.pred}} #2)
			(Bool/if Bits (Nat/eq remainder #Zero)
				#O{(Nat/to-bits quotient)}
				#I{(Nat/to-bits quotient)})
	}
}

// Tests the to-bits function for natural numbers.

// Test: to-bits 0 = O E.
TEST_0
: (Equal Bits (Nat/to-bits #Zero) (#O{#E}))
= #Refl

// Test: to-bits 1 = I E.
TEST_1
: (Equal Bits (Nat/to-bits #1) (#I{#E}))
= #Refl

// Test: to-bits 2 = O (I E).
TEST_2
: (Equal Bits (Nat/to-bits #2) (#O{#I{#E}}))
= #Refl

// Test: to-bits 3 = I (I E).
TEST_3
: (Equal Bits (Nat/to-bits #3) (#I{#I{#E}}))
= #Refl

// Test: to-bits 4 = O (O (I E)).
TEST_4
: (Equal Bits (Nat/to-bits #4) (#O{#O{#I{#E}}}))
= #Refl

// Test: to-bits 5 = I (O (I E)).
TEST_5
: (Equal Bits (Nat/to-bits #5) (#I{#O{#I{#E}}}))
= #Refl

// Test: to-bits 8 = O (O (O (I E))).
TEST_6
: (Equal Bits (Nat/to-bits #8) (#O{#O{#O{#I{#E}}}}))
= #Refl

// Test: to-bits 15 = I (I (I (I E))).
TEST_7
: (Equal Bits (Nat/to-bits #15) (#I{#I{#I{#I{#E}}}}))
= #Refl