// Recursively converts a Bits representation to Nat.
// 1st: The Bits to convert.
// 2nd: The weight or power of 2 to be applied for the current bit position.
// = The Nat representation of the input Bits after recursive processing.
Bits/to-nat-go
: ∀(bits: Bits)
  ∀(weight: Nat)
  Nat
= λ{
  #E: λweight #Zero
  #O: λb.tail λweight (Bits/to-nat-go b.tail (Nat/mul #2 weight))
  #I: λb.tail λweight (Nat/add weight (Bits/to-nat-go b.tail (Nat/mul #2 weight)))
}

// Converts a binary representation (Bits) to its Nat value.
// 1st: The Bits to convert.
// = The Nat representation of the input Bits.
Bits/to-nat
: ∀(bits: Bits)
  Nat
= λbits (Bits/to-nat-go bits #1)
// Test: Empty bits should convert to zero
TEST_0 
: (Equal Nat (Bits/to-nat #E) #Zero)
= #Refl

// Test: Single zero bit should convert to zero
TEST_1 
: (Equal Nat (Bits/to-nat (#O{#E})) #Zero)
= #Refl

// Test: Single one bit should convert to one
TEST_2 
: (Equal Nat (Bits/to-nat (#I{#E})) #1)
= #Refl

// Test: Two bits '01' should convert to two
TEST_3 
: (Equal Nat (Bits/to-nat (#O{#I{#E}})) #2)
= #Refl

// Test: Two bits '11' should convert to three
TEST_4 
: (Equal Nat (Bits/to-nat (#I{#I{#E}})) #3)
= #Refl

// Test: Three bits '001' should convert to four
TEST_5 
: (Equal Nat (Bits/to-nat (#O{#O{#I{#E}}})) #4)
= #Refl

// Test: Three bits '101' should convert to five
TEST_6 
: (Equal Nat (Bits/to-nat (#I{#O{#I{#E}}})) #5)
= #Refl

// Test: Four bits '0101' should convert to ten
TEST_7 
: (Equal Nat (Bits/to-nat (#O{#I{#O{#I{#E}}}})) #10)
= #Refl

// Test: Five bits '10011' should convert to twenty-five
TEST_8 
: (Equal Nat (Bits/to-nat (#I{#O{#O{#I{#I{#E}}}}})) #25)
= #Refl
