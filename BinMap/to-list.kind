use BinMap/ as BM/
use BinTree/ as BT/
use Bits/ as BS/
use List/ as L/
use Maybe/ as M/
use Pair/ as P/

// Helper function to traverse the BinMap in breadth-first order
BM/to-list-go
: ∀(A: *)
  ∀(queue: (L/List (P/Pair BS/Bits (BM/BinMap A))))
  (L/List (P/Pair BS/Bits A))
= λA λ{
  #Nil: #Nil{}
  #Cons: λ{
		#Pair: λacc λ{
			#Leaf: λtail (BM/to-list-go A tail)
			#Node: λ{
				#None: λlft λrgt λtail 
					(BM/to-list-go A (L/append (P/Pair BS/Bits (BM/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil{}}})))
				#Some: λval λlft λrgt λtail
					#Cons{#Pair{acc val} (BM/to-list-go A (L/append (P/Pair BS/Bits (BM/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil{}}})))}
			}
		}
	} 
}

// Converts a BinMap to a List of (Bits,A) pairs in breadth-first order.
// The keys returned are sorted in ascending order.
// - A: The type of values stored in the BinMap.
// - m: The input BinMap.
// = A List of Pairs, where each Pair contains the Bits path and the corresponding value.
BM/to-list
: ∀(A: *)
  ∀(m: (BM/BinMap A))
  (L/List (P/Pair BS/Bits A))
= λA λm (BM/to-list-go A #Cons{#Pair{#E{} (BM/invert A m)} #Nil{}})