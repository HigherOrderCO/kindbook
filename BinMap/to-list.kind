// Helper function to traverse the BinMap in breadth-first order
BinMap/to-list-go
: ∀(A: *)
  ∀(queue: (List (Pair/Pair Bits (BinMap/BinMap A))))
  (List (Pair/Pair Bits A))
= λA λ{
  #Nil: #Nil
  #Cons: λ{
		#Pair: λacc λ{
			#Leaf: λtail (BinMap/to-list-go A tail)
			#Node: λ{
				#None: λlft λrgt λtail 
					(BinMap/to-list-go A (List/append (Pair/Pair Bits (BinMap/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil}})))
				#Some: λval λlft λrgt λtail
					#Cons{#Pair{acc val} (BinMap/to-list-go A (List/append (Pair/Pair Bits (BinMap/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil}})))}
			}
		}
	} 
}

// Converts a BinMap to a List of (Bits,A) pairs in breadth-first order.
// The keys returned are sorted in ascending order.
// - A: The type of values stored in the BinMap.
// - m: The input BinMap.
// = A List of Pairs, where each Pair contains the Bits path and the corresponding value.
BinMap/to-list
: ∀(A: *)
  ∀(m: (BinMap/BinMap A))
  (List (Pair/Pair Bits A))
= λA λm (BinMap/to-list-go A #Cons{#Pair{#E (BinMap/invert A m)} #Nil})
// Test: Empty map should result in an empty list
TEST_0
: (Equal
    (List (Pair/Pair Bits Bool))
    (BinMap/to-list Bool #Leaf)
    (#Nil))
= #Refl

// Test: BinMap with a single element
TEST_1
: (Equal
    (List (Pair/Pair Bits Bool))
    (BinMap/to-list Bool (BinMap/set Bool #Leaf #E #True))
    (#Cons{(#Pair{#E #True}) (#Nil)}))
= #Refl

// Test: Overwrite element
TEST_2
: (Equal
    (List (Pair/Pair Bits Bool))
    (BinMap/to-list Bool (BinMap/set Bool (BinMap/set Bool #Leaf #E #True) #E #False))
    (#Cons{(#Pair{#E #False}) (#Nil)}))
= #Refl

// // Test: Skip None values 
// // BUG: Constructor Cons not found in pattern match.
// T3
// : (Equal
//     (List (Pair/Pair Bits Bool))
//     (BinMap/to-list Bool 
//       (#Node{
// 				#None
//         (#Node{#Some{#True} #Leaf #Leaf})
//         (#Node{#Some{#False} #Leaf #Leaf})}))
//     (#Cons{(#Pair{(#O{#E}) #True}) (#Cons{(#Pair{(#I{#E}) #False}) #Nil})}))
// = #Refl