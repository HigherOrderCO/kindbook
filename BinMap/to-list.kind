use BinMap/ as BM/
use BinTree/ as BT/
use Bits/ as BS/
use List/ as L/
use Maybe/ as M/
use Pair/ as P/

// Helper function to traverse the BinMap in breadth-first order
BM/to-list-go
: ∀(A: *)
  ∀(queue: (L/List (P/Pair BS/Bits (BM/BinMap A))))
  (L/List (P/Pair BS/Bits A))
= λA λ{
  #Nil: #Nil{}
  #Cons: λ{
		#Pair: λacc λ{
			#Leaf: λtail (BM/to-list-go A tail)
			#Node: λ{
				#None: λlft λrgt λtail 
					(BM/to-list-go A (L/append (P/Pair BS/Bits (BM/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil{}}})))
				#Some: λval λlft λrgt λtail
					#Cons{#Pair{acc val} (BM/to-list-go A (L/append (P/Pair BS/Bits (BM/BinMap A)) tail (#Cons{#Pair{#O{acc} lft} #Cons{#Pair{#I{acc} rgt} #Nil{}}})))}
			}
		}
	} 
}

// Converts a BinMap to a List of (Bits,A) pairs in breadth-first order.
// The keys returned are sorted in ascending order.
// - A: The type of values stored in the BinMap.
// - m: The input BinMap.
// = A List of Pairs, where each Pair contains the Bits path and the corresponding value.
BM/to-list
: ∀(A: *)
  ∀(m: (BM/BinMap A))
  (L/List (P/Pair BS/Bits A))
= λA λm (BM/to-list-go A #Cons{#Pair{#E{} (BM/invert A m)} #Nil{}})
//TEST//

use BinMap/ as BM/
use List/ as L/
use Pair/ as P/
use Bits/ as BS/
use Equal/ as E/
use Bool/ as B/
use Maybe/ as M/

// Test: Empty map should result in an empty list
T0
: (E/Equal
    (L/List (P/Pair BS/Bits B/Bool))
    (BM/to-list B/Bool #Leaf{})
    (#Nil{}))
= #Refl{}

// Test: BinMap with a single element
T1
: (E/Equal
    (L/List (P/Pair BS/Bits B/Bool))
    (BM/to-list B/Bool (BM/set B/Bool #Leaf{} #E{} #True{}))
    (#Cons{(#Pair{#E{} #True{}}) (#Nil{})}))
= #Refl{}

// Test: Overwrite element
T2
: (E/Equal
    (L/List (P/Pair BS/Bits B/Bool))
    (BM/to-list B/Bool (BM/set B/Bool (BM/set B/Bool #Leaf{} #E{} #True{}) #E{} #False{}))
    (#Cons{(#Pair{#E{} #False{}}) (#Nil{})}))
= #Refl{}

// // Test: Skip None values 
// // BUG: Constructor Cons not found in pattern match.
// T3
// : (E/Equal
//     (L/List (P/Pair BS/Bits B/Bool))
//     (BM/to-list B/Bool 
//       (#Node{
// 				#None{}
//         (#Node{#Some{#True{}} #Leaf{} #Leaf{}})
//         (#Node{#Some{#False{}} #Leaf{} #Leaf{}})}))
//     (#Cons{(#Pair{(#O{#E{}}) #True{}}) (#Cons{(#Pair{(#I{#E{}}) #False{}}) #Nil{}})}))
// = #Refl{}