use BinMap/ as BM/
use Bits/ as BS/
use Maybe/ as M/
use BinTree/ as BT/
use Pair/ as P/
use Equal/ as E/
use Nat/ as N/

// Test: Swapping in an empty map
T0
: (E/Equal
	(P/Pair (BM/BinMap N/Nat) (M/Maybe N/Nat))
	(BM/swap N/Nat (BM/new N/Nat) #E{} #Succ{#Succ{#Zero{}}})
  (#Pair{
      #Node{#Some{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}}
      #None{}}))
= #Refl{}

// Test: Swapping at the root of a non-empty map
T1
: let initial_map = #Node{#Some{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}}
  (E/Equal
	(P/Pair (BM/BinMap N/Nat) (M/Maybe N/Nat))
	(BM/swap N/Nat initial_map #E{} (#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}))
  (#Pair{
      #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}}
      #Some{#Succ{#Succ{#Zero{}}}}}))
= #Refl{}

// Test: Swapping in the left subtree
T2
: let initial_map = #Node{#None{} #Node{#Some{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}} #Leaf{}}
  (E/Equal
	(P/Pair (BM/BinMap N/Nat) (M/Maybe N/Nat))
	(BM/swap N/Nat initial_map (#O{#E{}}) (#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}))
  (#Pair{
      #Node{#None{} #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}} #Leaf{}}
      #Some{#Succ{#Succ{#Succ{#Zero{}}}}}}))
= #Refl{}

// Test: Swapping in the right subtree
T3
: let initial_map = #Node{#None{} #Leaf{} #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}} #Leaf{} #Leaf{}}}
  (E/Equal
	(P/Pair (BM/BinMap N/Nat) (M/Maybe N/Nat))
	(BM/swap N/Nat initial_map (#I{#E{}}) (#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}))
  (#Pair{
      #Node{#None{} #Leaf{} #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}} #Leaf{} #Leaf{}}}
      #Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}))
= #Refl{}

// Test: Swapping a non-existent key
T4
: let initial_map = #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}} #Leaf{} #Leaf{}}
  (E/Equal
	(P/Pair (BM/BinMap N/Nat) (M/Maybe N/Nat))
	(BM/swap N/Nat initial_map (#O{#E{}}) (#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}))
  (#Pair{
      #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}} #Node{#Some{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}} #Leaf{} #Leaf{}} #Leaf{}}
      #None{}}))
= #Refl{}