use BinMap/ as BM/
use BinTree/ as BT/
use Maybe/ as M/

// Helper function for inverting and splitting a BinMap
BM/invert-split-go
: ∀(A: *)
  ∀(x: (M/Maybe A))
  ∀(a: (BM/BinMap A))
  ∀(b: (BM/BinMap A))
  (BM/BinMap A)
= λA λx λ{
    #Leaf: λ{
			#Leaf: #Node{x #Leaf{} #Leaf{}}
			#Node: λbval λblft λbrgt (BM/invert-split-go A x (#Node{#None{} #Leaf{} #Leaf{}}) (#Node{bval blft brgt}))
		}
    #Node: λaval λalft λargt λ{
			#Leaf: (BM/invert-split-go A x (#Node{aval alft argt}) (#Node{#None{} #Leaf{} #Leaf{}}))
			#Node: λbval λblft λbrgt #Node{x #Node{aval alft blft} #Node{bval argt brgt}}
		}
  }

// Inverts and splits a BinMap
BM/invert-split
: ∀(A: *)
  ∀(m: (BM/BinMap A))
  (BM/BinMap A)
= λA λ{
    #Leaf: #Leaf{}
    #Node: λval λlft λrgt (BM/invert-split-go A val (BM/invert-split A lft) (BM/invert-split A rgt))
  }

// Inverts a BinMap
// Note: This function is not guaranteed to terminate for all inputs
BM/invert
: ∀(A: *)
  ∀(m: (BM/BinMap A))
  (BM/BinMap A)
= λA λm
	let inv = (BM/invert-split A m)
	use leaf = #Leaf{}
	use node = λval λlft λrgt λl λr (#Node{val (BM/invert A l) (BM/invert A r)})
	(BT/match (M/Maybe A) (λx (BM/BinMap A)) leaf node inv)
//TEST//

use BinMap/ as BM/
use Bits/ as BS/
use Equal/ as E/
use Maybe/ as M/

// Test: Inverting an empty BinMap should return an empty BinMap
T0
: (E/Equal (BM/BinMap BS/Bits) (BM/invert BS/Bits (BM/empty BS/Bits)) (BM/empty BS/Bits))
= #Refl{}

// Test: Inverting a BinMap with a single element should return the same BinMap
T1
: (E/Equal
    (BM/BinMap BS/Bits)
    (BM/invert BS/Bits (BM/set BS/Bits (BM/empty BS/Bits) #E{} (#O{#E{}})))
    (BM/set BS/Bits (BM/empty BS/Bits) #E{} (#O{#E{}})))
= #Refl{}

// Test: Inverting a BinMap twice should return the original BinMap
T2
: (E/Equal
    (BM/BinMap BS/Bits)
    (BM/invert BS/Bits (BM/invert BS/Bits (BM/set BS/Bits (BM/set BS/Bits (BM/empty BS/Bits) (#O{#E{}}) (#I{#E{}})) (#I{#E{}}) (#O{#E{}}))))
    (BM/set BS/Bits (BM/set BS/Bits (BM/empty BS/Bits) (#O{#E{}}) (#I{#E{}})) (#I{#E{}}) (#O{#E{}})))
= #Refl{}