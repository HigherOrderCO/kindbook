// Higher_order Virtual Machine
// ============================

// Core Types
// ----------

// Terms can be Positive or Negative
data HVM/Pol {
  #Pos
  #Neg
}

// A Term is a tree of IN nodes, ending in variables (aux wires)
data HVM/Term ~ (pol: HVM/Pol) {

  // Variables
  #Var{ uid: U64 } : (HVM/Term #Pos)
  #Sub{ uid: U64 } : (HVM/Term #Neg)

  // Eraser Nodes
  #Nul : (HVM/Term #Pos)
  #Era : (HVM/Term #Neg)

  // Constructor Nodes
  #Lam{ var: (HVM/Term #Neg) bod: (HVM/Term #Pos) } : (HVM/Term #Pos)
  #App{ arg: (HVM/Term #Pos) ret: (HVM/Term #Neg) } : (HVM/Term #Neg)

  // Duplicator Nodes
  #Sup{ tm1: (HVM/Term #Pos) tm2: (HVM/Term #Pos) } : (HVM/Term #Pos)
  #Dup{ dp1: (HVM/Term #Neg) dp2: (HVM/Term #Neg) } : (HVM/Term #Neg)

}

// A Tedex is a pair of Terms (trees connected by their main ports)
data HVM/Dex {
  #Dex{
    neg: (HVM/Term #Neg)
    pos: (HVM/Term #Pos)
  }
}

// A Bag is a list of redexes
HVM/Bag : *
= (List HVM/Dex)

// A Net is a Bag, plus a root Term
data HVM/Net {
  #Net{
    rot: (HVM/Term #Pos)
    bag: HVM/Bag
  }
}

// Runtime Types
// -------------

HVM/RTag : *
= U64

HVM/RLab  : * = U64
HVM/RLoc  : * = U64
HVM/RTerm : * = U64

data HVM/RHeap {
  #RHeap{
    mem: (Map U64)
    ini: U64
    end: U64
  }
}

HVM : * -> *
| A = (State HVM/RHeap A)

// Constants
// ---------

HVM/AIR : HVM/RTag = 0x00
HVM/VAR : HVM/RTag = 0x01
HVM/SUB : HVM/RTag = 0x02
HVM/NUL : HVM/RTag = 0x03
HVM/ERA : HVM/RTag = 0x04
HVM/LAM : HVM/RTag = 0x05
HVM/APP : HVM/RTag = 0x06
HVM/SUP : HVM/RTag = 0x07
HVM/DUP : HVM/RTag = 0x08

HVM/VOID : HVM/RTerm = 0x00000000_000000_00

HVM/RBAG : U64 = 0x1_0000_0000

// HVM Monad
// ---------

HVM/pure : ∀(A: *) A -> (HVM A)
= (State/pure HVM/RHeap)

HVM/bind : ∀(A: *) ∀(B: *) (HVM A) -> (A -> (HVM B)) -> (HVM B)
= (State/bind HVM/RHeap)

HVM/Monad : (Monad HVM)
= #Monad{
  pure: HVM/pure
  bind: HVM/bind
}

// Initialization
// --------------

HVM/Net/new : HVM/Net
= #Net{
  rot: #Nul
  bag: #Nil
}


HVM/RHeap/new : HVM/RHeap
= #RHeap{
  mem: {|0}
  ini: 0
  end: 3
}

// RTerm
// -----

// TODO: implement HVM/RTerm/new
HVM/RTerm/new : HVM/RTag -> HVM/RLab -> HVM/RLoc -> HVM/RTerm
| tag lab loc = 
  let tag_enc = tag
  let lab_enc = (<< lab 8)
  let loc_enc = (<< loc 32)
  (| tag_enc (| lab_enc loc_enc))

HVM/RTerm/get_tag : ∀(x: U64) HVM/RTag
| x = (& x 0xFF)

HVM/RTerm/get_lab : ∀(x: U64) HVM/RLab
| x = (& (>> x 8) 0xFF_FFFF)

HVM/RTerm/get_loc : ∀(x: U64) HVM/RLoc
| x = (& (>> x 32) 0xFFFF_FFFF)

HVM/RTag/eq : HVM/RTag -> HVM/RTag -> Bool
| x y = (U64/to_bool (== x y))

HVM/RTag/is-aux : HVM/RTag -> Bool
| x = when HVM/RTag/eq x {
  HVM/VAR: #True
  HVM/SUB: #True
} else {
  #False
}

HVM/RTag/is-pos : HVM/RTag -> Bool
| x = when HVM/RTag/eq x {
  HVM/VAR: #True
  HVM/NUL: #True
  HVM/LAM: #True
  HVM/SUP: #True
} else {
  #False
}

HVM/RTag/pol : HVM/RTag -> (Maybe HVM/Pol)
| x = when HVM/RTag/eq x {
  HVM/VAR: #Some{#Pos}
  HVM/SUB: #Some{#Neg}
  HVM/NUL: #Some{#Pos}
  HVM/ERA: #Some{#Neg}
  HVM/LAM: #Some{#Pos}
  HVM/APP: #Some{#Neg}
  HVM/SUP: #Some{#Pos}
  HVM/DUP: #Some{#Neg}
} else {
  #None
}

HVM/port : U64 -> U64 -> U64
| n x = (+ n x)

HVM/get-rheap : (HVM HVM/RHeap)
= λmem #Pair{ mem mem }

HVM/get-mem : (HVM (Map U64))
| #RHeap{mem ini end} = #Pair{#RHeap{mem ini end} mem}

HVM/get-ini : (HVM U64)
| #RHeap{mem ini end} = #Pair{#RHeap{mem ini end} ini}

HVM/get-end : (HVM U64)
| #RHeap{mem ini end} = #Pair{#RHeap{mem ini end} end}

//HVM/get-itrs : (HVM U64)
//= do HVM {
  //ask end = HVM/get-rbag-end
  //ret (/ end 2)
//}

// HVM Memory
// ----------

HVM/swap : HVM/RLoc -> HVM/RTerm -> (HVM HVM/RTerm)
| loc term #RHeap{mem ini end} =
  put got = mem[loc] := term
  #Pair{#RHeap{mem ini end} got}

HVM/get : U64 -> (HVM HVM/RTerm)
| loc #RHeap{mem ini end} =
  get got = mem[loc]
  #Pair{#RHeap{mem ini end} got}

HVM/set : U64 -> HVM/RTerm -> (HVM Unit)
| loc term = do HVM {
  ask (HVM/swap loc term)
  ret #Unit
}

//HVM/del : U64 -> (HVM Unit)
//| loc = do HVM {
  //ask (HVM/swap loc HVM/VOID)
  //ret #Unit
//}

HVM/take : U64 -> (HVM HVM/RTerm)
| loc = do HVM {
  (HVM/swap loc HVM/VOID)
}

HVM/just : U64 -> (HVM U64)
| loc = do HVM {
  ret loc
}

HVM/init : U64 -> HVM/RTerm -> (HVM Unit)
| loc term =
  if (U64/eq term HVM/VOID) do HVM {
    ret #Unit
  } else do HVM {
    ask (HVM/swap loc term)
    ret #Unit
  }

// Allocation
// ----------

HVM/alloc-node : U64 -> (HVM U64)
| arity #RHeap{mem ini end} =
  #Pair{#RHeap{mem ini (+ end arity)} end}

// Injection
// ---------
// Writes core terms into runtime memory.

HVM/VarMap : * = (Map (Maybe U64))

HVM/inject-term/var : U64 -> HVM/RTerm -> HVM/VarMap -> (HVM HVM/VarMap)
| uid up vars = 
  put got = vars[uid] := #Some{up}
  match got {
    #None: do HVM {
      ret vars
    }
    #Some{x}: do HVM {
      //log (String/join "" [(HVM/RTerm/to-string x) " ... " (HVM/RTerm/to-string up)])
      ask (HVM/set (HVM/RTerm/get-loc x) up)
      ask (HVM/set (HVM/RTerm/get-loc up) x)
      ret vars
    }
  }

HVM/inject-term : ∀(p: HVM/Pol) (HVM/Term p) -> HVM/RTerm -> HVM/VarMap -> (HVM (Pair HVM/VarMap HVM/RTerm))
| p #Nul up vars = do HVM {
  ret #Pair{vars (HVM/RTerm/new HVM/NUL 0 0)}
}
| p #Era up vars = do HVM {
  ret #Pair{vars (HVM/RTerm/new HVM/ERA 0 0)}
}
| p #Lam{var bod} up vars = do HVM {
  ask lam = (HVM/alloc-node 3)
  ask #Pair{vars var} = (HVM/inject-term #Neg var (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 lam)) vars)
  ask #Pair{vars bod} = (HVM/inject-term #Pos bod (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 lam)) vars)
  ask (HVM/init (HVM/port 0 lam) up)
  ask (HVM/init (HVM/port 1 lam) var)
  ask (HVM/init (HVM/port 2 lam) bod)
  ret #Pair{vars (HVM/RTerm/new HVM/LAM 0 lam)}
}
| p #App{arg ret} up vars = do HVM {
  ask app = (HVM/alloc-node 3)
  ask #Pair{vars arg} = (HVM/inject-term #Pos arg (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 app)) vars)
  ask #Pair{vars ret} = (HVM/inject-term #Neg ret (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 app)) vars)
  ask (HVM/init (HVM/port 0 app) up)
  ask (HVM/init (HVM/port 1 app) arg)
  ask (HVM/init (HVM/port 2 app) ret)
  ret #Pair{vars (HVM/RTerm/new HVM/APP 0 app)}
}
| p #Sup{tm1 tm2} up vars = do HVM {
  ask sup = (HVM/alloc-node 3)
  ask #Pair{vars tm1} = (HVM/inject-term #Pos tm1 (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 sup)) vars)
  ask #Pair{vars tm2} = (HVM/inject-term #Pos tm2 (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 sup)) vars)
  ask (HVM/init (HVM/port 0 sup) up)
  ask (HVM/init (HVM/port 1 sup) tm1)
  ask (HVM/init (HVM/port 2 sup) tm2)
  ret #Pair{vars (HVM/RTerm/new HVM/SUP 0 sup)}
}
| p #Dup{dp1 dp2} up vars = do HVM {
  ask dup = (HVM/alloc-node 3)
  ask #Pair{vars dp1} = (HVM/inject-term #Neg dp1 (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 dup)) vars)
  ask #Pair{vars dp2} = (HVM/inject-term #Neg dp2 (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 dup)) vars)
  ask (HVM/init (HVM/port 0 dup) up)
  ask (HVM/init (HVM/port 1 dup) dp1)
  ask (HVM/init (HVM/port 2 dup) dp2)
  ret #Pair{vars (HVM/RTerm/new HVM/DUP 0 dup)}
}
| p #Var{uid} up vars = do HVM {
  ask vars = (HVM/inject-term/var uid up vars)
  ret #Pair{vars HVM/VOID}
}
| p #Sub{uid} up vars = do HVM {
  ask vars = (HVM/inject-term/var uid up vars)
  ret #Pair{vars HVM/VOID}
}

HVM/inject_redex : HVM/Dex -> HVM/VarMap -> (HVM HVM/VarMap)
| #Dex{neg pos} vars = do HVM {
  ask #Pair{vars neg} = (HVM/inject-term #Neg neg HVM/VOID vars)
  ask #Pair{vars pos} = (HVM/inject-term #Pos pos HVM/VOID vars)
  ask (HVM/redex neg pos)
  ret vars
}

HVM/inject_net : HVM/Net -> HVM/VarMap -> (HVM (Pair HVM/VarMap HVM/RTerm))
| #Net{rot bag} vars = do HVM {
  ask #Pair{vars rot} = (HVM/inject-term #Pos rot (HVM/RTerm/new HVM/SUB 0 0) vars)
  ask vars = for dex in bag {
    (HVM/inject_redex dex vars)
  }
  ret #Pair{ vars rot }
}

HVM/do_inject_net : HVM/Net -> (HVM HVM/RTerm)
| net = do HVM {
  ask #Pair{x rot} = (HVM/inject_net net {|#None})
  ret rot
}

// Dumping
// -------
// Reads from runtime memory to handy containers.

HVM/dump : U64 -> U64 -> (HVM (List (Pair U64 HVM/RTerm)))
| ini end = if (U64/to-bool (< ini end)) do HVM {
  ask head = (HVM/get ini)
  ask tail = (HVM/dump (+ 1 ini) end)
  ret #Cons{(ini,head) tail}
} else do HVM {
  ret #Nil
}

HVM/dump-heap : (HVM (List (Pair U64 HVM/RTerm)))
= do HVM {
  ask ini = HVM/get-ini
  ask end = HVM/get-end
  (HVM/dump ini end)
}

// Recovery
// --------
// Reads from runtime memory to core terms.

HVM/recover_var : U64 -> HVM/RTerm -> (HVM (HVM/Term #Pos))
| var term = when HVM/RTag/eq (HVM/RTerm/get_tag term) {
  HVM/AIR: do HVM { ret log "ERR_D" #Nul }
  HVM/ERA: do HVM { ret log "ERR_E" #Nul }
  HVM/APP: do HVM { ret log "ERR_F" #Nul }
  HVM/DUP: do HVM { ret log "ERR_G" #Nul }
  HVM/VAR: (HVM/recover_term #Pos term)
  HVM/NUL: (HVM/recover_term #Pos term)
  HVM/LAM: (HVM/recover_term #Pos term)
  HVM/SUP: (HVM/recover_term #Pos term)
  HVM/SUB: if (U64/eq var (HVM/RTerm/get_loc term)) do HVM {
    ret #Var{(HVM/RTerm/get_loc term)}
  } else {
    (HVM/recover_term #Pos (HVM/RTerm/new HVM/SUB 0 (HVM/RTerm/get_loc term)))
  }
} else {
  do HVM { ret log "ERR_X" #Nul }
}

HVM/recover_sub : U64 -> HVM/RTerm -> (HVM (HVM/Term #Neg))
| sub term = when HVM/RTag/eq (HVM/RTerm/get_tag term) {
  HVM/AIR: do HVM { ret log "ERR_H" #Era }
  HVM/NUL: do HVM { ret log "ERR_I" #Era }
  HVM/LAM: do HVM { ret log "ERR_J" #Era }
  HVM/SUP: do HVM { ret log "ERR_K" #Era }
  HVM/VAR: (HVM/recover_term #Neg term)
  HVM/ERA: (HVM/recover_term #Neg term)
  HVM/APP: (HVM/recover_term #Neg term)
  HVM/DUP: (HVM/recover_term #Neg term)
  HVM/SUB: if (U64/eq sub (HVM/RTerm/get_loc term)) do HVM {
    ret #Sub{(HVM/RTerm/get_loc term)}
  } else {
    (HVM/recover_term #Neg (HVM/RTerm/new HVM/SUB 0 (HVM/RTerm/get_loc term)))
  }
} else {
  do HVM { ret log "ERR_X" #Era }
}

HVM/recover_term : ∀(p: HVM/Pol) (HVM/RTerm) -> (HVM (HVM/Term p))
| #Pos term = when HVM/RTag/eq (HVM/RTerm/get_tag term) {
  HVM/AIR: do HVM { ret #Nul }
  HVM/NUL: do HVM { ret #Nul }
  HVM/VAR: do HVM {
    ask got = (HVM/get (HVM/RTerm/get_loc term))
    (HVM/recover_var (HVM/RTerm/get_loc term) got)
  }
  HVM/LAM: do HVM {
    let loc = (HVM/RTerm/get_loc term)
    ask var = (HVM/get (HVM/port 1 loc))
    ask bod = (HVM/get (HVM/port 2 loc))
    ask var = (HVM/recover_term #Neg var)
    ask bod = (HVM/recover_term #Pos bod)
    ret #Lam{var bod}
  }
  HVM/SUP: do HVM {
    let loc = (HVM/RTerm/get_loc term)
    ask tm1 = (HVM/get (HVM/port 1 loc))
    ask tm2 = (HVM/get (HVM/port 2 loc))
    ask tm1 = (HVM/recover_term #Pos tm1)
    ask tm2 = (HVM/recover_term #Pos tm2)
    ret #Sup{tm1 tm2}
  }
  HVM/SUB: do HVM { ret log "ERR_L" #Nul }
  HVM/ERA: do HVM { ret log "ERR_M" #Nul }
  HVM/APP: do HVM { ret log "ERR_N" #Nul }
  HVM/DUP: do HVM { ret log "ERR_O" #Nul }
} else {
  do HVM { ret log "ERR_X" #Nul }
}
| #Neg term = when HVM/RTag/eq (HVM/RTerm/get_tag term) {
  HVM/AIR: do HVM { ret #Era }
  HVM/ERA: do HVM { ret #Era }
  HVM/SUB: do HVM {
    ask got = (HVM/get (HVM/RTerm/get_loc term))
    (HVM/recover_sub (HVM/RTerm/get_loc term) got)
  }
  HVM/APP: do HVM {
    let loc = (HVM/RTerm/get_loc term)
    ask arg = (HVM/get (HVM/port 1 loc))
    ask ret = (HVM/get (HVM/port 2 loc))
    ask arg = (HVM/recover_term #Pos arg)
    ask ret = (HVM/recover_term #Neg ret)
    ret #App{arg ret}
  }
  HVM/DUP: do HVM {
    let loc = (HVM/RTerm/get_loc term)
    ask dp1 = (HVM/get (HVM/port 1 loc))
    ask dp2 = (HVM/get (HVM/port 2 loc))
    ask dp1 = (HVM/recover_term #Neg dp1)
    ask dp2 = (HVM/recover_term #Neg dp2)
    ret #Dup{dp1 dp2}
  }
  HVM/VAR: do HVM { ret log "ERR_P" #Era }
  HVM/NUL: do HVM { ret log "ERR_Q" #Era }
  HVM/LAM: do HVM { ret log "ERR_R" #Era }
  HVM/SUP: do HVM { ret log "ERR_S" #Era }
} else {
  do HVM { ret log "ERR_X" #Era }
}

HVM/recover_rot : (HVM (HVM/Term #Pos))
= do HVM {
  ask rot = (HVM/get 0)
  (HVM/recover_term #Pos rot)
}

//HVM/recover-bag : (HVM HVM/Bag)
//= do HVM {
  //ask rbag = HVM/dump-rbag
  //let bag  = [] :: HVM/Bag
  //ask bag  = for loc_rdx in rbag {
    //let #Pair{loc rdx} = loc_rdx
    //let #Pair{neg pos} = rdx
    //ask neg = (HVM/recover-term #Neg neg)
    //ask pos = (HVM/recover-term #Pos pos)
    //ret #Cons{ #Dex{neg pos} bag }
  //}
  //ret bag
//}

//HVM/recover-net : (HVM HVM/Net)
//= do HVM {
  //ask rot = HVM/recover-rot
  //ask bag = HVM/recover-bag
  //ret #Net{ rot bag }
//}

// Running
// -------

HVM/boot : HVM/Net -> (HVM Unit)
= λnet do HVM {
  ask rot = (HVM/do_inject_net net)
  ask (HVM/init 0 rot)
  ret #Unit
}

HVM/run : ∀(A: *) (HVM A) -> A
= λA λhvm match (hvm HVM/RHeap/new) {
  #Pair{net x}: x
}

// Showing
// -------

HVM/Term/to_string : ∀(p: HVM/Pol) (HVM/Term p) -> String
| #Pos #Var{uid}     = (String/join "" ["+" (U64/to_hex_string uid)])
| #Pos #Sub{uid}     = #void
| #Pos #Nul          = "+*"
| #Pos #Era          = #void
| #Pos #Lam{var bod} = (String/join "" ["+(" (HVM/Term/to_string #Neg var) " " (HVM/Term/to_string #Pos bod) ")"])
| #Pos #App{arg ret} = #void
| #Pos #Sup{tm1 tm2} = (String/join "" ["+{" (HVM/Term/to_string #Pos tm1) " " (HVM/Term/to_string #Pos tm2) "}"])
| #Pos #Dup{dp1 dp2} = #void
| #Neg #Var{uid}     = #void
| #Neg #Sub{uid}     = (String/join "" ["-" (U64/to_hex_string uid)])
| #Neg #Nul          = #void
| #Neg #Era          = "-*"
| #Neg #Lam{var bod} = #void
| #Neg #App{arg ret} = (String/join "" ["-(" (HVM/Term/to_string #Pos arg) " " (HVM/Term/to_string #Neg ret) ")"])
| #Neg #Sup{tm1 tm2} = #void
| #Neg #Dup{dp1 dp2} = (String/join "" ["-{" (HVM/Term/to_string #Neg dp1) " " (HVM/Term/to_string #Neg dp2) "}"])

HVM/Bag/to_string : HVM/Bag -> String
| #Nil                        = ""
| #Cons{#Dex{neg pos} rest} = (String/join "" ["\n& " (HVM/Term/to_string #Neg neg) " ~ " (HVM/Term/to_string #Pos pos) (HVM/Bag/to_string rest)])

HVM/Net/to_string : HVM/Net -> String
| #Net{rot bag} = (String/join "" [(HVM/Term/to_string #Pos rot) (HVM/Bag/to_string bag)])

HVM/RTag/to_string : HVM/RTag -> String
| tag = when HVM/RTag/eq tag {
  HVM/AIR: "AIR"
  HVM/VAR: "VAR"
  HVM/SUB: "SUB"
  HVM/NUL: "NUL"
  HVM/ERA: "ERA"
  HVM/LAM: "LAM"
  HVM/APP: "APP"
  HVM/SUP: "SUP"
  HVM/DUP: "DUP"
} else {
  "???"
}

HVM/RLab/to_string : U64 -> String
| loc = (String/pad_left (U64/to_hex_string loc) #6 '0')

HVM/RLoc/to_string : U64 -> String
| loc = (String/pad_left (U64/to_hex_string loc) #9 '0')

HVM/RTerm/to_string : HVM/RTerm -> String 
| term =
  let tag = (HVM/RTag/to-string (HVM/RTerm/get-tag term))
  let lab = (HVM/RLab/to-string (HVM/RTerm/get-lab term))
  let loc = (HVM/RLoc/to-string (HVM/RTerm/get-loc term))
  (String/join "" ["Term(" tag ",0x" lab ",0x" loc ")"])

HVM/RHeap/to-string : (List (Pair U64 HVM/RTerm)) -> String
| heap = (List/fold _ heap _ "" (λkv λtxt
  let #Pair{k v} = kv
  let addr       = (String/pad-left (U64/to-hex-string k) #9 '0')
  let term       = (HVM/RTerm/to-string v)
  (String/join "" ["heap[0x" addr "] = " term "\n" txt])
))

// Parser
// ------

HVM/parse_term : ∀(p: HVM/Pol) (Parser (HVM/Term p))
| #Pos = do Parser {
  ask Parser/skip_trivia
  //ask text = Parser/get_input
  //log (String/join "" ["[[" text "]]"])
  ask head = Parser/peek_one
  when (Maybe/eq_with _ U64/eq) head {
    #Some{'('} : do Parser {
      ask (Parser/consume "(")
      ask var = (HVM/parse_term #Neg)
      ask bod = (HVM/parse_term #Pos)
      ask (Parser/consume ")")
      ret #Lam { var bod }
    }
    #Some{'{'} : do Parser {
      ask (Parser/consume "{")
      ask tm1 = (HVM/parse_term #Pos)
      ask tm2 = (HVM/parse_term #Pos)
      ask (Parser/consume "}")
      ret #Sup { tm1 tm2 }
    }
    #Some{'*'} : do Parser {
      ask (Parser/consume "*")
      ret #Nul
    }
  } else {
    do Parser {
      ask name = Parser/parse_name
      ret #Var { (U64/from_bits (String/to_bits name)) }
    }
  }
}
| #Neg = do Parser {
  ask Parser/skip_trivia
  ask head = Parser/peek_one
  when (Maybe/eq_with _ U64/eq) head {
    #Some{'('} : do Parser {
      ask (Parser/consume "(")
      ask arg = (HVM/parse_term #Pos)
      ask ret = (HVM/parse_term #Neg)
      ask (Parser/consume ")")
      ret #App { arg ret }
    }
    #Some{'{'} : do Parser {
      ask (Parser/consume "{")
      ask dp1 = (HVM/parse_term #Neg)
      ask dp2 = (HVM/parse_term #Neg)
      ask (Parser/consume "}")
      ret #Dup { dp1 dp2 }
    }
    #Some{'*'} : do Parser {
      ask (Parser/consume "*")
      ret #Era
    }
  } else {
    do Parser {
      ask name = Parser/parse_name
      ret #Sub { (U64/from_bits (String/to_bits name)) }
    }
  }
}

HVM/parse_bag : (Parser HVM/Bag)
= do Parser {
  ask Parser/skip_trivia
  ask head = Parser/peek_one
  when (Maybe/eq_with _ U64/eq) head {
    #Some{'&'} : do Parser {
      ask (Parser/consume "&")
      ask neg = (HVM/parse_term #Neg)
      ask Parser/skip_trivia
      ask (Parser/consume "~")
      ask pos = (HVM/parse_term #Pos)
      ask rest = HVM/parse_bag
      ret #Cons{ #Dex{neg pos} rest }
    }
  } else {
    do Parser {
      ret #Nil
    }
  }
}

HVM/parse_net : (Parser HVM/Net)
= do Parser {
  ask rot = (HVM/parse_term #Pos)
  ask bag = HVM/parse_bag
  ret #Net{ rot bag }
}

HVM/do_parse_net : String -> HVM/Net
= λcode (Maybe/run _ (Parser/run _ HVM/parse_net code) HVM/Net/new)

// Linking
// -------

HVM/move : U64 -> HVM/RTerm -> (HVM Unit)
| neg_loc pos = do HVM {
  ask neg = (HVM/swap neg_loc pos)
  if (HVM/RTag/eq (HVM/RTerm/get_tag neg) HVM/SUB) do HVM {
    //log "link N<~P subs"
    ret #Unit
  } else do HVM {
    (HVM/link neg pos)
  }
}

HVM/link : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
| neg pos = do HVM {
  if (HVM/RTag/eq (HVM/RTerm/get_tag pos) HVM/VAR) do HVM {
    ask far = (HVM/swap (HVM/RTerm/get_loc pos) neg)
    if (HVM/RTag/eq (HVM/RTerm/get_tag far) HVM/SUB) do HVM {
      //log "link N~>P subs"
      ret #Unit
    } else do HVM {
      //log "link N~>P recs"
      (HVM/move (HVM/RTerm/get_loc pos) far)
    }
  } else do HVM {
    ask (HVM/redex neg pos)
    ret #Unit
  }
}

HVM/redex : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
| neg pos = do HVM {
  ask (HVM/set (HVM/RTerm/get-loc neg) pos)
  ask (HVM/set (HVM/RTerm/get-loc pos) neg)
  ret #Unit
}

// Interaction
// -----------

HVM/interact : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
| a b = do HVM {
  let a_tag = (HVM/RTerm/get-tag a)
  let a_lab = (HVM/RTerm/get-lab a)
  let a_loc = (HVM/RTerm/get-loc a)
  let b_tag = (HVM/RTerm/get-tag b)
  let b_lab = (HVM/RTerm/get-lab b)
  let b_loc = (HVM/RTerm/get-loc b)
  ask (HVM/set a_loc 0) 
  ask (HVM/set b_loc 0) 
  when HVM/RTag/eq a_tag {
    HVM/APP: when HVM/RTag/eq b_tag {
      HVM/LAM: do HVM {
        log "APP-LAM"
        ask arg = (HVM/take (HVM/port 1 a_loc))
        ask ret = (HVM/just (HVM/port 2 a_loc))
        ask var = (HVM/just (HVM/port 1 b_loc))
        ask bod = (HVM/take (HVM/port 2 b_loc))
        ask (HVM/move var arg)
        ask (HVM/move ret bod)
        ret #Unit
      }
      HVM/SUP: do HVM {
        log "APP-SUP"
        ask arg = (HVM/take (HVM/port 1 a_loc))
        ask ret = (HVM/just (HVM/port 2 a_loc))
        ask tm1 = (HVM/take (HVM/port 1 b_loc))
        ask tm2 = (HVM/take (HVM/port 2 b_loc))
        ask dp1 = (HVM/alloc-node 3)
        ask dp2 = (HVM/alloc-node 3)
        ask cn1 = (HVM/alloc-node 3)
        ask cn2 = (HVM/alloc-node 3)
        ask (HVM/set (HVM/port 1 dp1) (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 dp1)))
        ask (HVM/set (HVM/port 2 dp1) (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 dp1)))
        ask (HVM/set (HVM/port 1 dp2) (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 cn1)))
        ask (HVM/set (HVM/port 2 dp2) (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 cn2)))
        ask (HVM/set (HVM/port 1 cn1) (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 dp1)))
        ask (HVM/set (HVM/port 2 cn1) (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 cn1)))
        ask (HVM/set (HVM/port 1 cn2) (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 dp1)))
        ask (HVM/set (HVM/port 2 cn2) (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 cn2)))
        ask (HVM/link (HVM/RTerm/new HVM/DUP 0 dp1) arg)
        ask (HVM/move ret (HVM/RTerm/new HVM/SUP 0 dp2))
        ask (HVM/link (HVM/RTerm/new HVM/APP 0 cn1) tm1)
        ask (HVM/link (HVM/RTerm/new HVM/APP 0 cn2) tm2)
        ret #Unit
      }
      HVM/NUL: do HVM {
        log "APP-NUL"
        ask arg = (HVM/take (HVM/port 1 a_loc))
        ask ret = (HVM/just (HVM/port 2 a_loc))
        ask (HVM/link (HVM/RTerm/new HVM/ERA 0 0) arg)
        ask (HVM/move ret (HVM/RTerm/new HVM/NUL 0 0))
        ret #Unit
      }
    } else { do HVM { ret #Unit } }
    HVM/DUP: when HVM/RTag/eq b_tag {
      HVM/SUP: do HVM {
        log "DUP-SUP"
        ask dp1 = (HVM/just (HVM/port 1 a_loc))
        ask dp2 = (HVM/just (HVM/port 2 a_loc))
        ask tm1 = (HVM/take (HVM/port 1 b_loc))
        ask tm2 = (HVM/take (HVM/port 2 b_loc))
        ask (HVM/move dp1 tm1)
        ask (HVM/move dp2 tm2)
        ret #Unit
      }
      HVM/LAM: do HVM {
        log "DUP-LAM"
        ask dp1 = (HVM/just (HVM/port 1 a_loc))
        ask dp2 = (HVM/just (HVM/port 2 a_loc))
        ask var = (HVM/just (HVM/port 1 b_loc))
        ask bod = (HVM/take (HVM/port 2 b_loc))
        ask co1 = (HVM/alloc-node 3)
        ask co2 = (HVM/alloc-node 3)
        ask du1 = (HVM/alloc-node 3)
        ask du2 = (HVM/alloc-node 3)
        ask (HVM/set (HVM/port 1 co1) (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 co1)))
        ask (HVM/set (HVM/port 2 co1) (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 du2)))
        ask (HVM/set (HVM/port 1 co2) (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 co2)))
        ask (HVM/set (HVM/port 2 co2) (HVM/RTerm/new HVM/VAR 0 (HVM/port 2 du2)))
        ask (HVM/set (HVM/port 1 du1) (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 co1)))
        ask (HVM/set (HVM/port 2 du1) (HVM/RTerm/new HVM/VAR 0 (HVM/port 1 co2)))
        ask (HVM/set (HVM/port 1 du2) (HVM/RTerm/new HVM/SUB 0 (HVM/port 1 du2)))
        ask (HVM/set (HVM/port 2 du2) (HVM/RTerm/new HVM/SUB 0 (HVM/port 2 du2)))
        ask (HVM/move dp1 (HVM/RTerm/new HVM/LAM 0 co1))
        ask (HVM/move dp2 (HVM/RTerm/new HVM/LAM 0 co2))
        ask (HVM/move var (HVM/RTerm/new HVM/SUP 0 du1))
        ask (HVM/link (HVM/RTerm/new HVM/DUP 0 du2) bod)
        ret #Unit
      }
      HVM/NUL: do HVM {
        log "DUP-NUL"
        ask dp1 = (HVM/just (HVM/port 1 a_loc))
        ask dp2 = (HVM/just (HVM/port 2 a_loc))
        ask (HVM/move dp1 (HVM/RTerm/new HVM/NUL 0 0))
        ask (HVM/move dp2 (HVM/RTerm/new HVM/NUL 0 0))
        ret #Unit
      }
    } else { do HVM { ret #Unit } }
    HVM/ERA: when HVM/RTag/eq b_tag {
      HVM/LAM: do HVM {
        log "ERA-LAM"
        ask var = (HVM/just (HVM/port 1 b_loc))
        ask bod = (HVM/take (HVM/port 2 b_loc))
        ask (HVM/move var (HVM/RTerm/new HVM/NUL 0 0))
        ask (HVM/link (HVM/RTerm/new HVM/ERA 0 0) bod)
        ret #Unit
      }
      HVM/SUP: do HVM {
        log "ERA-SUP"
        ask tm1 = (HVM/take (HVM/port 1 b_loc))
        ask tm2 = (HVM/take (HVM/port 2 b_loc))
        ask (HVM/link (HVM/RTerm/new HVM/ERA 0 0) tm1)
        ask (HVM/link (HVM/RTerm/new HVM/ERA 0 0) tm2)
        ret #Unit
      }
      HVM/NUL: do HVM {
        log "ERA-NUL"
        ret #Unit
      }
    } else { log "NO-OP" do HVM { ret #Unit } }
  } else { log "NO-OP" do HVM { ret #Unit } }
}

// Evaluation
// ----------

//pub fn reduce(&mut self, book: &Book, mut prev: Ptr) -> Ptr {
  ////println!("reduce {}", prev.view());
  //let mut path : Vec<Ptr> = vec![];

  //loop {
    //// Load ptrs
    ////println!("move {}", prev.view());

    //let next = self.get_target_full(prev);
    ////println!("---> {}", next.view());

    ////println!("ROOT={} {}", self.heap.get_root().view(), self.get_target(self.heap.get_root()).view());

    //// If next is ref, dereferences
    //if next.is_ref() {
      ////println!("CALL");
      //self.call(book, next, prev);
      ////println!("{}", self.view());
      ////println!("{}", crate::ast::show_runtime_net(self));
      //continue;
    //}

    //// If next is root, stop.
    //if next == ROOT {
      ////println!("DONE!");
      //break ;
    //}

    //// If next is a main port...
    //if next.is_pri() {
      //// If prev is a main port, reduce the active pair.
      //if prev.is_pri() {
        ////println!("REDEX {} {}", prev.view(), next.view());
        //self.interact(book, prev, next);
        ////println!("{}", self.view());
        ////println!("{}", crate::ast::show_runtime_net(self));
        //prev = path.pop().unwrap();
        //continue;
      //// Otherwise, we're done.
      //} else {
        ////println!("AXIOM!");
        //break;
      //}
    //}

    //// If next is an aux port, pass through.
    //let main = self.heap.get_pri(next.loc());
    ////println!("CONT next: {} | main: {} ~ {}", next.view(), main.0.view(), main.1.view());
    //path.push(prev);
    //prev = main.this;
  //}

  ////println!("done");
  //return self.get_target_full(prev);
//}

// TODO: implement the reduce function. port the logic from Rust to Kind.
// don't port parts that do not apply. keep the same algorithm.

HVM/reduce : U64 -> HVM/RTerm -> (List HVM/RTerm) -> (HVM HVM/RTerm)
| r prev path =
  if (U64/eq r 8) do HVM {
    ret #Unit
  } else do HVM {
    ask next     = (HVM/get (HVM/RTerm/get-loc prev))
    log (String/join "" [(HVM/RTerm/to-string prev) " -> " (HVM/RTerm/to-string next)])
    let prev_tag = (HVM/RTerm/get-tag prev)
    let prev_loc = (HVM/RTerm/get-loc prev)
    let next_tag = (HVM/RTerm/get-tag next)
    let next_loc = (HVM/RTerm/get-loc next)
    //if (HVM/RTag/eq (HVM/RTerm/get-loc prev) 0) do HVM {
      //log "DONE"
      //ret #Unit
    //} else
    if (HVM/RTag/is-pos next_tag) do HVM { 
      log "FLIP"
      (HVM/reduce (+ r 1) next path)
    } else if (HVM/RTag/is-aux prev_tag) do HVM {
      log "MOVE"
      use path = #Cons{prev path}
      ask prev = (HVM/get (- prev_loc (% prev_loc 3)))
      //ask prev = (HVM/get (HVM/RTerm/get-loc next))
      ask (HVM/reduce (+ r 1) prev path)
    } else if (HVM/RTag/is-aux next_tag) do HVM {
      log "WHNF"
      ret #Unit
    } else do HVM {
      log "INTR"
      ask (HVM/interact next prev)
      match path {
        #Nil: do HVM { log "ERR" ret HVM/VOID }
        #Cons{prev path}: (HVM/reduce (+ r 1) prev path)
      }
    }
  }

// Main
// ----

main
: String/View
= (HVM/run _ do HVM {

  // not^(2^4)(true) - 264 ITRS
  let f4 = "q
    & ((p (* p)) q) ~ (m o)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
  "

  // not^(2^8)(true) - 4120 ITRS
  let f8 = "cb
    & ((bb (* bb)) cb) ~ (y ab)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
  "

  // not^(2^12)(true) - 65576 ITRS
  let fC = "ob
    & ((nb (* nb)) ob) ~ (kb mb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
  "

  // not^(2^14)(true) - 262192 ITRS
  let fC = "ub
    & ((tb (* tb)) ub) ~ (qb sb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
    & {(ob pb) (nb ob)} ~ (kb mb)
    & {(rb sb) (qb rb)} ~ (nb pb)"

  // not^(2^16)(true) - 1048632 ITRS
  let fG = "ac
    & ((zb (* zb)) ac) ~ (wb yb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
    & {(ob pb) (nb ob)} ~ (kb mb)
    & {(rb sb) (qb rb)} ~ (nb pb)
    & {(ub vb) (tb ub)} ~ (qb sb)
    & {(xb yb) (wb xb)} ~ (tb vb)
  "

  //let fH = "
    //gc
    //& (cc ec) ~ ((fc (* fc)) gc)
    //& (((* (a a)) ((b (* b)) c)) c) ~ {(e f) (d e)}
    //& (d f) ~ {(h i) (g h)}
    //& (g i) ~ {(k l) (j k)}
    //& (j l) ~ {(n o) (m n)}
    //& (m o) ~ {(q r) (p q)}
    //& (p r) ~ {(t u) (s t)}
    //& (s u) ~ {(w x) (v w)}
    //& (v x) ~ {(z ab) (y z)}
    //& (y ab) ~ {(cb db) (bb cb)}
    //& (bb db) ~ {(fb gb) (eb fb)}
    //& (eb gb) ~ {(ib jb) (hb ib)}
    //& (hb jb) ~ {(lb mb) (kb lb)}
    //& (kb mb) ~ {(ob pb) (nb ob)}
    //& (nb pb) ~ {(rb sb) (qb rb)}
    //& (qb sb) ~ {(ub vb) (tb ub)}
    //& (tb vb) ~ {(xb yb) (wb xb)}
    //& (wb yb) ~ {(ac bc) (zb ac)}
    //& (zb bc) ~ {(dc ec) (cc dc)}
  //"

  // Parses
  let net = (HVM/do-parse-net "c & ((b b) c) ~ (a a)")

  
  //let net = (HVM/do-parse-net f4)

  // Sanity Check
  log "[NET]"
  log ((HVM/Net/to-string net) :: String)
  
  // Boots Net
  ask (HVM/boot net)

  ask prev = (HVM/get 0)
  //ask next = (HVM/get (HVM/RTerm/get-loc next))
  log (String/join "" ["init: " (HVM/RTerm/to-string prev)])
  ask (HVM/reduce 0 prev [])

  // Backup
  log "[RHeap]"
  ask rheap = HVM/get_rheap
  log rheap

  //// Normalizes
  //ask HVM/eval_strict

  ////// Results
  //ask itrs = HVM/get-itrs
  ask term  = HVM/recover-rot
  ask rheap = HVM/dump-heap
  log (HVM/RHeap/to-string rheap)
  //log (HVM/Term/to-string #Pos term)

  //log term

  //// Logs
  //log "[ITRS]"
  //log (U64/to-string itrs)
  //log "[NET]"
  //log (HVM/Net/to-string net)
  //log "[RNET]"
  //log (HVM/RNet/to-string rnet)

  // Returns result
  ret #View{"ok"}
})

//Kind: 365 IPS
//[ITRS]
//4119
//[NET]
//+(-4880 +(-* +4880))
//"ok"
//kind run HVM/HVM.kind  10.89s user 0.32s system 99% cpu 11.266 total

//JS: 71093 IPS
//[ITRS]
//262191
//[NET]
//+(-120110 +(-* +120110))
//node HVM/HVM.js  4.04s user 0.22s system 115% cpu 3.688 total

//Kind: 4096 IPS after native Map
//[ITRS]
//262191
//[NET]
//+(-120110 +(-* +120110))
//"ok"

//JS: after native map
//[ITRS]
//262191
//[NET]
//+(-120110 +(-* +120110))
//node HVM/HVM.js  0.87s user 0.03s system 108% cpu 0.833 total

//λt((t ((λ* $a) *)) ((λ$a *) *))

//*
//& @(* *) ~ λ(-a *)
//& @(* *) ~ λ(* +a)

//APP_LAM
//>> #LINK{"SUB" 5 "NUL" 0}
//link X<~B subs
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B
//APP_LAM
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B
//>> #LINK{"ERA" 0 "VAR" 5}
//link A~>X done
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B

//APP_LAM
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B
//>> #LINK{"ERA" 0 "VAR" 11}
//link A~>X subs
//APP_LAM
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B
//>> #LINK{"ERA" 0 "NUL" 0}
//link A~~B



//[NET]
//+(-* +a)
//& -(+(-b +b) -(+(-c +c) -a)) ~ +(-(+d -e) +(-d +e))

//heap[0x000000000] = Term(LAM,0x000000,0x000000001)

//heap[0x000000001] = Term(SUB,0x000000,0x000000000)
//heap[0x000000002] = Term(ERA,0x000000,0x000000000)
//heap[0x000000003] = Term(VAR,0x000000,0x00000000C)

//heap[0x000000004] = Term(LAM,0x000000,0x000000010)
//heap[0x000000005] = Term(LAM,0x000000,0x000000007)
//heap[0x000000006] = Term(APP,0x000000,0x00000000A)

//heap[0x000000007] = Term(SUB,0x000000,0x000000005)
//heap[0x000000008] = Term(SUB,0x000000,0x000000009)
//heap[0x000000009] = Term(VAR,0x000000,0x000000008)

//heap[0x00000000A] = Term(VAR,0x000000,0x000000006)
//heap[0x00000000B] = Term(LAM,0x000000,0x00000000D)
//heap[0x00000000C] = Term(SUB,0x000000,0x000000003)

//heap[0x00000000D] = Term(SUB,0x000000,0x00000000B)
//heap[0x00000000E] = Term(SUB,0x000000,0x00000000F)
//heap[0x00000000F] = Term(VAR,0x000000,0x00000000E)

//heap[0x000000010] = Term(APP,0x000000,0x000000004)
//heap[0x000000011] = Term(APP,0x000000,0x000000013)
//heap[0x000000012] = Term(LAM,0x000000,0x000000016)

//heap[0x000000013] = Term(VAR,0x000000,0x000000011)
//heap[0x000000014] = Term(VAR,0x000000,0x000000017)
//heap[0x000000015] = Term(SUB,0x000000,0x000000018)

//heap[0x000000016] = Term(SUB,0x000000,0x000000012)
//heap[0x000000017] = Term(SUB,0x000000,0x000000014)
//heap[0x000000018] = Term(VAR,0x000000,0x000000015)

