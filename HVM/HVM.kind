//./../HVM_old.kind//

// NOTE: the code above is HVM's old code. The code below is HVM's new code.
// We're refactoring the old HVM to use HVM/Map, and U64 instead of Bits.

// Higher-order Virtual Machine
// ============================

// Core Types
// ----------

data HVM/Pol {
  #Pos
  #Neg
}

data HVM/Term ~ (pol: HVM/Pol) {
  #Var{ uid: U64 } : (HVM/Term #Pos)
  #Sub{ uid: U64 } : (HVM/Term #Neg)
  #Nul : (HVM/Term #Pos)
  #Era : (HVM/Term #Neg)
  #Lam{ var: (HVM/Term #Neg) bod: (HVM/Term #Pos) } : (HVM/Term #Pos)
  #App{ arg: (HVM/Term #Pos) ret: (HVM/Term #Neg) } : (HVM/Term #Neg)
  #Sup{ tm1: (HVM/Term #Pos) tm2: (HVM/Term #Pos) } : (HVM/Term #Pos)
  #Dup{ dp1: (HVM/Term #Neg) dp2: (HVM/Term #Neg) } : (HVM/Term #Neg)
}

data HVM/Redex {
  #Redex{
    neg: (HVM/Term #Neg)
    pos: (HVM/Term #Pos)
  }
}

HVM/Bag : *
= (List HVM/Redex)

data HVM/Net {
  #Net{
    rot: (HVM/Term #Pos)
    bag: HVM/Bag
  }
}

// Runtime Types
// -------------

data HVM/RTag {
  #AIR
  #VAR
  #SUB
  #NUL
  #ERA
  #LAM
  #APP
  #SUP
  #DUP
}

HVM/RLab : *
= U64

HVM/RLoc : *
= U64

data HVM/RTerm {
  #RTerm{
    tag: HVM/RTag
    lab: HVM/RLab
    loc: HVM/RLoc
  }
}

data HVM/RRedex {
  #RRedex{
    neg: HVM/RTerm
    pos: HVM/RTerm
  }
}

HVM/RBag : *
= (List HVM/RRedex)

data HVM/RRange {
  #RRange{
    ini: U64
    end: U64
  }
}

data HVM/RBuff {
  #RBuff{
    map: (BinMap U64)
  }
}

data HVM/RNet {
  #RNet{
    buff: HVM/RBuff
    node: HVM/RRange
    rbag: HVM/RRange
  }
}

HVM : * -> *
| A = (State HVM/RNet A)

// Constants
// ---------

HVM/RBAG : U64
= 0x1_0000_0000

// HVM Monad
// ---------

HVM/pure : ∀(A: *) A -> (HVM A)
= (State/pure HVM/RNet)

HVM/bind : ∀(A: *) ∀(B: *) (HVM A) -> (A -> (HVM B)) -> (HVM B)
= (State/bind HVM/RNet)

HVM/Monad : (Monad HVM)
= #Monad{
  pure: HVM/pure
  bind: HVM/bind
}

// Initialization
// --------------

HVM/Net/new : HVM/Net
= #Net{
  rot: #Nul
  bag: #Nil
}


HVM/RNet/new : HVM/RNet
= #RNet{
  buff: #RBuff{ (BinMap/new _) }
  node: #RRange{ 0 1 }
  rbag: #RRange{ 0 0 }
}

// Term
// ----

HVM/Term/is-sub : ∀(pol: HVM/Pol) (HVM/Term pol) -> Bool
| #Pos #Sub{uid} = #True
| pol  term      = #False

HVM/Term/is-var : ∀(pol: HVM/Pol) (HVM/Term pol) -> Bool
| #Pos #Var{uid} = #True
| pol  term      = #False

// RTerm
// -----

HVM/RTag/decode : U64 -> HVM/RTag
= λ{
  0x00: #AIR
  0x01: #VAR
  0x02: #SUB
  0x03: #NUL
  0x04: #ERA
  0x05: #LAM
  0x06: #APP
  0x07: #SUP
  0x08: #DUP
  0x08+k: log "ERR-A" #ERA
}

HVM/RTag/encode : HVM/RTag -> U64
| #AIR = 0x00
| #VAR = 0x01
| #SUB = 0x02
| #NUL = 0x03
| #ERA = 0x04
| #LAM = 0x05
| #APP = 0x06
| #SUP = 0x07
| #DUP = 0x08

HVM/RTerm/decode : ∀(x: U64) HVM/RTerm
| x =
  let tag = (HVM/RTag/decode (& x 0xFF))
  let lab = (& (>> x 8) 0xFF_FFFF)
  let val = (& (>> x 32) 0xFFFF_FFFF)
  #RTerm{ tag lab val }

HVM/RTerm/encode : HVM/RTerm -> U64
| #RTerm{tag lab loc} =
  let tag = (HVM/RTag/encode tag)
  let lab = (<< lab 8)
  let loc = (<< loc 32)
  (+ tag (+ lab loc))

HVM/RTag/is-air : HVM/RTag -> Bool
| #AIR = #True
| else = #False

HVM/RTag/is-sub : HVM/RTag -> Bool
| #SUB = #True
| else = #False

HVM/RTag/is-var : HVM/RTag -> Bool
| #VAR = #True
| else = #False

HVM/RTerm/get-tag : HVM/RTerm -> HVM/RTag
| #RTerm{tag lab loc} = tag

HVM/RTerm/get-lab : HVM/RTerm -> HVM/RLab
| #RTerm{tag lab loc} = lab

HVM/RTerm/get-loc : HVM/RTerm -> HVM/RLoc
| #RTerm{tag lab loc} = loc

HVM/at : U64 -> U64 -> U64
| n x = (+ n x)

HVM/get-itrs : (HVM U64)
| #RNet{buff node #RRange{ini end}} = #Pair{#RNet{buff node #RRange{ini end}} (/ end 2)}

// RBuff
// -----

HVM/RBuff/key : U64 -> Bits
| key = (Bits/reverse (U64/to-bits key))

HVM/RBuff/swap : HVM/RBuff -> U64 -> U64 -> (Pair HVM/RBuff U64)
| #RBuff{map} key val =
  let #Pair{map got} = (BinMap/swap _ map (HVM/RBuff/key key) #Some{val})
  #Pair{#RBuff{map} (Maybe/run _ 0 got)}

// HVM Memory
// ----------

HVM/swap : HVM/RLoc -> HVM/RTerm -> (HVM HVM/RTerm)
| loc term #RNet{buff node rbag} =
  let encoded_term    = (HVM/RTerm/encode term)
  let #Pair{buff got} = (HVM/RBuff/swap buff loc encoded_term)
  let decoded_term    = (HVM/RTerm/decode got)
  #Pair{#RNet{buff node rbag} decoded_term}

HVM/get : U64 -> (HVM HVM/RTerm)
| loc = do HVM {
  ask got = (HVM/swap loc #RTerm{#AIR 0 0})
  ask air = (HVM/swap loc got)
  ret got
}

HVM/set : U64 -> HVM/RTerm -> (HVM Unit)
| loc term = do HVM {
  ask (HVM/swap loc term)
  ret #Unit
}

HVM/del : U64 -> (HVM Unit)
| loc = do HVM {
  ask (HVM/swap loc #RTerm{#AIR 0 0})
  ret #Unit
}

HVM/take : U64 -> (HVM HVM/RTerm)
| loc = do HVM {
  ask term = (HVM/swap loc #RTerm{#AIR 0 0})
  let subs = (HVM/RTag/is-sub (HVM/RTerm/get-tag term))
  if subs do HVM {
    ask (HVM/swap loc term)
    ret term
  } else do HVM {
    ret term
  }
}

HVM/init : U64 -> HVM/RTerm -> (HVM Unit)
| loc term = do HVM {
  ask old = (HVM/swap loc term)
  let air = (HVM/RTag/is-air (HVM/RTerm/get-tag old))
  if air do HVM {
    ret #Unit
  } else do HVM {
    ask (HVM/swap loc old)
    ret #Unit
  }
}

// Utils
// -----

HVM/get-rnet : (HVM HVM/RNet)
= λnet #Pair{ net net }

HVM/get-rrot : (HVM HVM/RTerm)
= (HVM/get 0)

HVM/get-rbag : (HVM HVM/RBag)
= do HVM {
  ask net = HVM/get-rnet
  let #RNet{buff node rbag} = net
  let #RRange{rbag_ini rbag_end} = rbag
  (HVM/get-rbag/go rbag_ini rbag_end)
}

HVM/get-rbag/go : U64 -> U64 -> (HVM HVM/RBag)
| ini end = 
  if (U64/to-bool (< ini end)) do HVM {
    ask neg  = (HVM/get (+ HVM/RBAG (+ ini 0)))
    ask pos  = (HVM/get (+ HVM/RBAG (+ ini 1)))
    use head = #RRedex{neg pos}
    ask tail = (HVM/get-rbag/go (+ ini 2) end)
    ret #Cons{head tail}
  } else do HVM {
    ret #Nil
  }

HVM/get-net : (HVM HVM/Net)
= do HVM {
  ask net = HVM/get-rnet
  (HVM/recover-net net)
}

// Allocation
// ----------

HVM/alloc-node : U64 -> (HVM U64)
| arity #RNet{buff #RRange{node_ini node_end} rbag} =
  #Pair{#RNet{buff #RRange{node_ini (+ node_end arity)} rbag} node_end}

HVM/alloc-redex : (HVM U64)
| #RNet{buff node #RRange{rbag_ini rbag_end}} =
  #Pair{#RNet{buff node #RRange{rbag_ini (+ rbag_end 2)}} (+ HVM/RBAG rbag_end)}

HVM/next-redex : (HVM (Maybe U64))
| #RNet{buff node #RRange{rbag_ini rbag_end}} =
  if (U64/to-bool (< rbag_ini rbag_end)) {
    #Pair{#RNet{buff node #RRange{(+ rbag_ini 2) rbag_end}} #Some{(+ HVM/RBAG rbag_ini)}}
  } else {
    #Pair{#RNet{buff node #RRange{rbag_ini rbag_end}} #None}
  }

HVM/push-redex : HVM/RRedex -> (HVM Unit)
| #RRedex{neg pos} = do HVM {
  ask loc = HVM/alloc-redex
  ask (HVM/set (+ loc 0) neg)
  ask (HVM/set (+ loc 1) pos)
  ret #Unit
}

HVM/pop-redex : (HVM (Maybe HVM/RRedex))
= do HVM {
  ask loc = HVM/next-redex
  match loc {
    #None: do HVM {
      ret #None
    }
    #Some{loc}: do HVM {
      ask neg = (HVM/get (+ loc 0))
      ask pos = (HVM/get (+ loc 1))
      ask (HVM/set (+ loc 0) #RTerm{ #AIR 0 0 })
      ask (HVM/set (+ loc 1) #RTerm{ #AIR 0 0 })
      ret #Some{#RRedex{ neg pos }}
    }
  }
}
  
// Injection
// ---------

HVM/VarMap : *
= (BinMap U64)

HVM/inject-term : ∀(p: HVM/Pol) (HVM/Term p) -> (Maybe U64) -> HVM/VarMap -> (HVM (Pair HVM/VarMap HVM/RTerm))
| p #Lam{var bod} host vars = do HVM {
  ask lam             = (HVM/alloc-node 3)
  ask #Pair{vars var} = (HVM/inject-term #Neg var #Some{(HVM/at 1 lam)} vars)
  ask #Pair{vars bod} = (HVM/inject-term #Pos bod #Some{(HVM/at 2 lam)} vars)
  ask (HVM/init (HVM/at 1 lam) var)
  ask (HVM/init (HVM/at 2 lam) bod)
  ret #Pair{ vars #RTerm{ #LAM 0 lam } }
}
| p #App{arg ret} host vars = do HVM {
  ask app             = (HVM/alloc-node 3)
  ask #Pair{vars arg} = (HVM/inject-term #Pos arg #Some{(HVM/at 1 app)} vars)
  ask #Pair{vars ret} = (HVM/inject-term #Neg ret #Some{(HVM/at 2 app)} vars)
  ask (HVM/init (HVM/at 1 app) arg)
  ask (HVM/init (HVM/at 2 app) ret)
  ret #Pair{ vars #RTerm{ #APP 0 app } }
}
| p #Sup{tm1 tm2} host vars = do HVM {
  ask sup             = (HVM/alloc-node 3)
  ask #Pair{vars tm1} = (HVM/inject-term #Pos tm1 #Some{(HVM/at 1 sup)} vars)
  ask #Pair{vars tm2} = (HVM/inject-term #Pos tm2 #Some{(HVM/at 2 sup)} vars)
  ask (HVM/init (HVM/at 1 sup) tm1)
  ask (HVM/init (HVM/at 2 sup) tm2)
  ret #Pair{ vars #RTerm{ #SUP 0 sup } }
}
| p #Dup{dp1 dp2} host vars = do HVM {
  ask dup             = (HVM/alloc-node 3)
  ask #Pair{vars dp1} = (HVM/inject-term #Neg dp1 #Some{(HVM/at 1 dup)} vars)
  ask #Pair{vars dp2} = (HVM/inject-term #Neg dp2 #Some{(HVM/at 2 dup)} vars)
  ask (HVM/init (HVM/at 1 dup) dp1)
  ask (HVM/init (HVM/at 2 dup) dp2)
  ret #Pair{ vars #RTerm{ #DUP 0 dup } }
}
| p #Var{uid} #None vars = do HVM {
  ret log "ERR-B" #Pair{ vars #RTerm{ #NUL 0 0 } }
}
| p #Var{uid} #Some{host} vars = 
  let #Pair{vars got} = (BinMap/swap _ vars (Bits/reverse (U64/to-bits uid)) #Some{host})
  match got {
    #None: do HVM { ret #Pair{ vars #RTerm{ #NUL 0 0 } } }
    #Some{neg_host}: do HVM { ret #Pair{ vars #RTerm{ #VAR 0 neg_host } } }
  }
| p #Sub{uid} #None vars = do HVM {
  ret log "ERR-C" #Pair{ vars #RTerm{ #NUL 0 0 } }
}
| p #Sub{uid} #Some{host} vars = 
  let #Pair{vars got} = (BinMap/swap _ vars (Bits/reverse (U64/to-bits uid)) #Some{host})
  match got {
    #None: do HVM { ret #Pair{ vars #RTerm{ #SUB 0 host } } }
    #Some{pos_host}: do HVM {
      ask (HVM/set pos_host (#RTerm{ #VAR 0 host }))
      ret #Pair{ vars #RTerm{ #SUB 0 host } }
    }
  }
| p #Nul host vars = do HVM {
  ret #Pair{ vars #RTerm{ #NUL 0 0 } }
}
| p #Era host vars = do HVM {
  ret #Pair{ vars #RTerm{ #ERA 0 0 } }
}

HVM/inject-redex : HVM/Redex -> HVM/VarMap -> (HVM HVM/VarMap)
| #Redex{neg pos} vars = do HVM {
  ask #Pair{vars neg} = (HVM/inject-term #Neg neg #None vars)
  ask #Pair{vars pos} = (HVM/inject-term #Pos pos #None vars)
  ask (HVM/push-redex #RRedex{neg pos})
  ret vars
}

HVM/inject-net : HVM/Net -> HVM/VarMap -> (HVM (Pair HVM/VarMap HVM/RTerm))
| #Net{rot bag} vars = do HVM {
  ask #Pair{vars rot} = (HVM/inject-term #Pos rot #Some{0} vars)
  ask vars = for dex in bag {
    (HVM/inject-redex dex vars)
  }
  ret #Pair{ vars rot }
}

HVM/do-inject-net : HVM/Net -> (HVM HVM/RTerm)
| net = do HVM {
  ask #Pair{x rot} = (HVM/inject-net net (BinMap/new _))
  ret rot
}

// Recovery
// --------

HVM/recover-var : U64 -> HVM/RTerm -> (HVM (HVM/Term #Pos))
| var #RTerm{#AIR tag loc} = do HVM { ret log "ERR-D" #Nul }
| var #RTerm{#ERA tag loc} = do HVM { ret log "ERR-E" #Nul }
| var #RTerm{#APP tag loc} = do HVM { ret log "ERR-F" #Nul }
| var #RTerm{#DUP tag loc} = do HVM { ret log "ERR-G" #Nul }
| var #RTerm{#VAR tag loc} = (HVM/recover-term #Pos (#RTerm{ #VAR tag loc }))
| var #RTerm{#NUL tag loc} = (HVM/recover-term #Pos (#RTerm{ #NUL tag loc }))
| var #RTerm{#LAM tag loc} = (HVM/recover-term #Pos (#RTerm{ #LAM tag loc }))
| var #RTerm{#SUP tag loc} = (HVM/recover-term #Pos (#RTerm{ #SUP tag loc }))
| var #RTerm{#SUB tag loc} = if (U64/eq var loc) do HVM {
  ret #Var{loc}
} else {
  (HVM/recover-term #Pos #RTerm{ #SUB tag loc })
}

HVM/recover-sub : U64 -> HVM/RTerm -> (HVM (HVM/Term #Neg))
| sub #RTerm{#AIR tag loc} = do HVM { ret log "ERR-H" #Era }
| sub #RTerm{#NUL tag loc} = do HVM { ret log "ERR-I" #Era }
| sub #RTerm{#LAM tag loc} = do HVM { ret log "ERR-J" #Era }
| sub #RTerm{#SUP tag loc} = do HVM { ret log "ERR-K" #Era }
| sub #RTerm{#VAR tag loc} = (HVM/recover-term #Neg (#RTerm{ #VAR tag loc }))
| sub #RTerm{#ERA tag loc} = (HVM/recover-term #Neg (#RTerm{ #ERA tag loc }))
| sub #RTerm{#APP tag loc} = (HVM/recover-term #Neg (#RTerm{ #APP tag loc }))
| sub #RTerm{#DUP tag loc} = (HVM/recover-term #Neg (#RTerm{ #DUP tag loc }))
| sub #RTerm{#SUB tag loc} = if (U64/eq sub loc) do HVM {
  ret #Sub{loc}
} else {
  (HVM/recover-term #Neg (#RTerm{ #SUB tag loc }))
}

HVM/recover-term : ∀(p: HVM/Pol) (HVM/RTerm) -> (HVM (HVM/Term p))
| #Pos #RTerm{#AIR tag loc} = do HVM { ret #Nul }
| #Pos #RTerm{#NUL tag loc} = do HVM { ret #Nul }
| #Pos #RTerm{#VAR tag loc} = do HVM {
  ask got = (HVM/get loc)
  (HVM/recover-var loc got)
}
| #Pos #RTerm{#LAM tag loc} = do HVM {
  ask var = (HVM/get (HVM/at 1 loc))
  ask bod = (HVM/get (HVM/at 2 loc))
  ask var = (HVM/recover-term #Neg var)
  ask bod = (HVM/recover-term #Pos bod)
  ret #Lam{var bod}
}
| #Pos #RTerm{#SUP tag loc} = do HVM {
  ask tm1 = (HVM/get (HVM/at 1 loc))
  ask tm2 = (HVM/get (HVM/at 2 loc))
  ask tm1 = (HVM/recover-term #Pos tm1)
  ask tm2 = (HVM/recover-term #Pos tm2)
  ret #Sup{tm1 tm2}
}
| #Pos #RTerm{#SUB tag loc} = do HVM { ret log "ERR-L" #Nul }
| #Pos #RTerm{#ERA tag loc} = do HVM { ret log "ERR-M" #Nul }
| #Pos #RTerm{#APP tag loc} = do HVM { ret log "ERR-N" #Nul }
| #Pos #RTerm{#DUP tag loc} = do HVM { ret log "ERR-O" #Nul }
| #Neg #RTerm{#AIR tag loc} = do HVM { ret #Era }
| #Neg #RTerm{#ERA tag loc} = do HVM { ret #Era }
| #Neg #RTerm{#SUB tag loc} = do HVM {
  ask got = (HVM/get loc)
  (HVM/recover-sub loc got)
}
| #Neg #RTerm{#APP tag loc} = do HVM {
  ask arg = (HVM/get (HVM/at 1 loc))
  ask ret = (HVM/get (HVM/at 2 loc))
  ask arg = (HVM/recover-term #Pos arg)
  ask ret = (HVM/recover-term #Neg ret)
  ret #App{arg ret}
}
| #Neg #RTerm{#DUP tag loc} = do HVM {
  ask dp1 = (HVM/get (HVM/at 1 loc))
  ask dp2 = (HVM/get (HVM/at 2 loc))
  ask dp1 = (HVM/recover-term #Neg dp1)
  ask dp2 = (HVM/recover-term #Neg dp2)
  ret #Dup{dp1 dp2}
}
| #Neg #RTerm{#VAR tag loc} = do HVM { ret log "ERR-P" #Era }
| #Neg #RTerm{#NUL tag loc} = do HVM { ret log "ERR-Q" #Era }
| #Neg #RTerm{#LAM tag loc} = do HVM { ret log "ERR-R" #Era }
| #Neg #RTerm{#SUP tag loc} = do HVM { ret log "ERR-S" #Era }

HVM/recover-bag : HVM/RBag -> (HVM HVM/Bag)
| #Nil = do HVM {
  ret #Nil
}
| #Cons{#RRedex{neg pos} rest} = do HVM {
  ask neg  = (HVM/recover-term #Neg neg)
  ask pos  = (HVM/recover-term #Pos pos)
  ask rest = (HVM/recover-bag rest)
  ret #Cons{ #Redex{neg pos} rest }
}

HVM/recover-net : HVM/RNet -> (HVM HVM/Net)
= λnet do HVM {
  ask rot = HVM/get-rrot
  ask bag = HVM/get-rbag
  ask rot = (HVM/recover-term #Pos rot)
  ask bag = (HVM/recover-bag bag)
  ret #Net{ rot bag }
}

// Running
// -------

HVM/boot : HVM/Net -> (HVM Unit)
= λnet do HVM {
  ask rot = (HVM/do-inject-net net)
  ask (HVM/init 0 rot)
  ret #Unit
}

HVM/run : ∀(A: *) (HVM A) -> A
= λA λhvm match (hvm HVM/RNet/new) {
  #Pair{net x}: x
}

// Showing
// -------

HVM/Term/to-string : ∀(p: HVM/Pol) (HVM/Term p) -> String
| #Pos #Var{uid}     = (String/join "" ["+" (U64/to-hex-string uid)])
| #Pos #Sub{uid}     = #void
| #Pos #Nul          = "+*"
| #Pos #Era          = #void
| #Pos #Lam{var bod} = (String/join "" ["+(" (HVM/Term/to-string #Neg var) " " (HVM/Term/to-string #Pos bod) ")"])
| #Pos #App{arg ret} = #void
| #Pos #Sup{tm1 tm2} = (String/join "" ["+{" (HVM/Term/to-string #Pos tm1) " " (HVM/Term/to-string #Pos tm2) "}"])
| #Pos #Dup{dp1 dp2} = #void
| #Neg #Var{uid}     = #void
| #Neg #Sub{uid}     = (String/join "" ["-" (U64/to-hex-string uid)])
| #Neg #Nul          = #void
| #Neg #Era          = "-*"
| #Neg #Lam{var bod} = #void
| #Neg #App{arg ret} = (String/join "" ["-(" (HVM/Term/to-string #Pos arg) " " (HVM/Term/to-string #Neg ret) ")"])
| #Neg #Sup{tm1 tm2} = #void
| #Neg #Dup{dp1 dp2} = (String/join "" ["-{" (HVM/Term/to-string #Neg dp1) " " (HVM/Term/to-string #Neg dp2) "}"])

HVM/Bag/to-string : HVM/Bag -> String
| #Nil                        = ""
| #Cons{#Redex{neg pos} rest} = (String/join "" ["\n& " (HVM/Term/to-string #Neg neg) " ~ " (HVM/Term/to-string #Pos pos) (HVM/Bag/to-string rest)])

HVM/Net/to-string : HVM/Net -> String
| #Net{rot bag} = (String/join "" [(HVM/Term/to-string #Pos rot) (HVM/Bag/to-string bag)])

// complete with all missing stringification fns below
// NOTE: for the runtime, we will just stringify the RBuff, with 9 hex chars (no ranges)

HVM/RTag/to-string : HVM/RTag -> String
| #AIR = "AIR"
| #VAR = "VAR"
| #SUB = "SUB"
| #NUL = "NUL"
| #ERA = "ERA"
| #LAM = "LAM"
| #APP = "APP"
| #SUP = "SUP"
| #DUP = "DUP"

HVM/RLab/to-string : U64 -> String
| loc = (String/pad-left #6 '0' (U64/to-hex-string loc))

HVM/RLoc/to-string : U64 -> String
| loc = (String/pad-left #9 '0' (U64/to-hex-string loc))

HVM/RTerm/to-string : HVM/RTerm -> String 
| #RTerm{tag lab loc} =
  let tag = (HVM/RTag/to-string tag)
  let lab = (HVM/RLab/to-string lab)
  let loc = (HVM/RLoc/to-string loc)
  (String/join "" [tag ":" lab ":" loc])

HVM/RBuff/to-string : HVM/RBuff -> String
| #RBuff{map} = (List/fold _ (BinMap/to-list _ map) _ "" (λkv λtxt
  let #Pair{k v} = kv
  if (U64/to-bool (== v 0)) {
    txt
  } else {
    let loc = (String/pad-left #9 '0' (U64/to-hex-string (Bits/to-u64 k)))
    let val = (HVM/RTerm/to-string (HVM/RTerm/decode v))
    (String/join "" [loc " → " val "\n" txt])
  }
))

HVM/RNet/to-string : HVM/RNet -> String
| #RNet{buff node rbag} = (String/join "" ["BUFF:\n" (HVM/RBuff/to-string buff)])

HVM/RRange/to-string : HVM/RRange -> String
| #RRange{ini end} = (String/join "" [
  (U64/to-hex-string ini) ".." (U64/to-hex-string end)
])

// Parser
// ------

HVM/parse-term : ∀(p: HVM/Pol) (Parser (HVM/Term p))
| #Pos = do Parser {
  ask Parser/skip-trivia
  //ask text = Parser/get-input
  //log (String/join "" ["[[" text "]]"])
  ask head = Parser/peek-one
  when (Maybe/eq-with _ U64/eq) head {
    #Some{'('} : do Parser {
      ask (Parser/consume "(")
      ask var = (HVM/parse-term #Neg)
      ask bod = (HVM/parse-term #Pos)
      ask (Parser/consume ")")
      ret #Lam { var bod }
    }
    #Some{'{'} : do Parser {
      ask (Parser/consume "{")
      ask tm1 = (HVM/parse-term #Pos)
      ask tm2 = (HVM/parse-term #Pos)
      ask (Parser/consume "}")
      ret #Sup { tm1 tm2 }
    }
    #Some{'*'} : do Parser {
      ask (Parser/consume "*")
      ret #Nul
    }
    _ : do Parser {
      ask name = Parser/parse-name
      ret #Var { (U64/from-bits (String/to-bits name)) }
    }
  }
}
| #Neg = do Parser {
  ask Parser/skip-trivia
  ask head = Parser/peek-one
  when (Maybe/eq-with _ U64/eq) head {
    #Some{'('} : do Parser {
      ask (Parser/consume "(")
      ask arg = (HVM/parse-term #Pos)
      ask ret = (HVM/parse-term #Neg)
      ask (Parser/consume ")")
      ret #App { arg ret }
    }
    #Some{'{'} : do Parser {
      ask (Parser/consume "{")
      ask dp1 = (HVM/parse-term #Neg)
      ask dp2 = (HVM/parse-term #Neg)
      ask (Parser/consume "}")
      ret #Dup { dp1 dp2 }
    }
    #Some{'*'} : do Parser {
      ask (Parser/consume "*")
      ret #Era
    }
    _ : do Parser {
      ask name = Parser/parse-name
      ret #Sub { (U64/from-bits (String/to-bits name)) }
    }
  }
}

HVM/parse-bag : (Parser HVM/Bag)
= do Parser {
  ask Parser/skip-trivia
  ask head = Parser/peek-one
  when (Maybe/eq-with _ U64/eq) head {
    #Some{'&'} : do Parser {
      ask (Parser/consume "&")
      ask neg = (HVM/parse-term #Neg)
      ask Parser/skip-trivia
      ask (Parser/consume "~")
      ask pos = (HVM/parse-term #Pos)
      ask rest = HVM/parse-bag
      ret #Cons{ #Redex{neg pos} rest }
    }
    _ : do Parser {
      ret #Nil
    }
  }
}

HVM/parse-net : (Parser HVM/Net)
= do Parser {
  ask rot = (HVM/parse-term #Pos)
  ask bag = HVM/parse-bag
  ret #Net{ rot bag }
}

HVM/do-parse-net : String -> HVM/Net
= λcode (Maybe/run _ HVM/Net/new (Parser/run _ HVM/parse-net code))

// Linking
// -------

// FIXME: not working on current flattener

//HVM/link : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
//| #RTerm{#SUB l} b = do HVM { ask x = (HVM/swap l b) (HVM/link-sub l x) }
//| a #RTerm{#VAR l} = do HVM { ask x = (HVM/swap l a) (HVM/link-var l x) }
//| a b              = do HVM { ask (HVM/push-redex #Pair{a b}) ret #Unit }

//HVM/link-sub : Bits -> (Maybe HVM/RTerm) -> (HVM Unit)
//| l #Some{#RTerm{#SUB _}} = do HVM { ret #Unit }
//| l #Some{a}              = do HVM { ask b = (HVM/take l) (HVM/link a b) }
//| l #None                 = do HVM { ret #Unit }

//HVM/link-var : Bits -> (Maybe HVM/RTerm) -> (HVM Unit)
//| l #Some{#RTerm{#SUB _}} = do HVM { ret #Unit }
//| l #Some{b}              = do HVM { ask a = (HVM/take l) (HVM/link a b) }
//| l #None                 = do HVM { ret #Unit }

HVM/link : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
| #RTerm{at ak al} b = match (HVM/RTag/is-sub at) { 
  #True  : do HVM { ask x = (HVM/swap al b) (HVM/link-sub al x) }
  #False : match b {
    #RTerm{bt bk bl}: match (HVM/RTag/is-var bt) {
      #True: do HVM {
        use a = #RTerm{at ak al}
        ask x = (HVM/swap bl a)
        (HVM/link-var bl x)
      }
      #False: do HVM {
        use a = #RTerm{at ak al}
        ask (HVM/push-redex #RRedex{a b})
        ret #Unit
      }
    }
  }
}

HVM/link-sub : U64 -> HVM/RTerm -> (HVM Unit)
| l #RTerm{at ak al} = match (HVM/RTag/is-sub at) {
  #True: do HVM {
    ret #Unit
  }
  #False: do HVM {
    use a = #RTerm{at ak al}
    ask b = (HVM/take l)
    (HVM/link a b)
  }
}

HVM/link-var : U64 -> HVM/RTerm -> (HVM Unit)
| l #RTerm{bt ak bl} = match (HVM/RTag/is-sub bt) {
  #True: do HVM {
    ret #Unit
  }
  #False: do HVM {
    use b = #RTerm{bt ak bl}
    ask a = (HVM/take l)
    (HVM/link a b)
  }
}

// Interaction
// -----------

HVM/interact : HVM/RTerm -> HVM/RTerm -> (HVM Unit)
| #RTerm{at ak al} #RTerm{bt bk bl} = (HVM/interact/go at ak al bt bk bl)

HVM/interact/go
: HVM/RTag -> HVM/RLab -> HVM/RLoc ->
  HVM/RTag -> HVM/RLab -> HVM/RLoc ->
  (HVM Unit)
| #APP app_lab app_loc #LAM lam_lab lam_loc = do HVM {
  log "APP-LAM"
  ask arg = (HVM/take (HVM/at 1 app_loc))
  ask ret = (HVM/take (HVM/at 2 app_loc))
  ask var = (HVM/take (HVM/at 1 lam_loc))
  ask bod = (HVM/take (HVM/at 2 lam_loc))
  ask (HVM/link var arg)
  ask (HVM/link ret bod)
  ret #Unit
}
| #APP app_lab app_loc #SUP sup_lab sup_loc = do HVM {
  log "APP-SUP"
  ask arg = (HVM/take (HVM/at 1 app_loc))
  ask ret = (HVM/take (HVM/at 2 app_loc))
  ask tm1 = (HVM/take (HVM/at 1 sup_loc))
  ask tm2 = (HVM/take (HVM/at 2 sup_loc))
  ask dp1 = (HVM/alloc-node 3)
  ask dp2 = (HVM/alloc-node 3)
  ask cn1 = (HVM/alloc-node 3)
  ask cn2 = (HVM/alloc-node 3)
  ask (HVM/set (HVM/at 1 dp1) (#RTerm{ #SUB 0 (HVM/at 1 dp1) }))
  ask (HVM/set (HVM/at 2 dp1) (#RTerm{ #SUB 0 (HVM/at 2 dp1) }))
  ask (HVM/set (HVM/at 1 dp2) (#RTerm{ #VAR 0 (HVM/at 2 cn1) }))
  ask (HVM/set (HVM/at 2 dp2) (#RTerm{ #VAR 0 (HVM/at 2 cn2) }))
  ask (HVM/set (HVM/at 1 cn1) (#RTerm{ #VAR 0 (HVM/at 1 dp1) }))
  ask (HVM/set (HVM/at 2 cn1) (#RTerm{ #SUB 0 (HVM/at 2 cn1) }))
  ask (HVM/set (HVM/at 1 cn2) (#RTerm{ #VAR 0 (HVM/at 2 dp1) }))
  ask (HVM/set (HVM/at 2 cn2) (#RTerm{ #SUB 0 (HVM/at 2 cn2) }))
  ask (HVM/link (#RTerm{ #DUP 0 dp1 }) arg)
  ask (HVM/link ret (#RTerm{ #SUP 0 dp2 }))
  ask (HVM/link (#RTerm{ #APP 0 cn1 }) tm1)
  ask (HVM/link (#RTerm{ #APP 0 cn2 }) tm2)
  ret #Unit
}
| #APP app_lab app_loc #NUL nul_lab nul_loc = do HVM {
  log "APP-NUL"
  ask arg = (HVM/take (HVM/at 1 app_loc))
  ask ret = (HVM/take (HVM/at 2 app_loc))
  ask (HVM/link (#RTerm{ #ERA 0 0 }) arg)
  ask (HVM/link ret (#RTerm{ #NUL 0 0 }))
  ret #Unit
}
| #DUP dup_lab dup_loc #SUP sup_lab sup_loc = do HVM {
  log "DUP-SUP"
  ask dp1 = (HVM/take (HVM/at 1 dup_loc))
  ask dp2 = (HVM/take (HVM/at 2 dup_loc))
  ask tm1 = (HVM/take (HVM/at 1 sup_loc))
  ask tm2 = (HVM/take (HVM/at 2 sup_loc))
  ask (HVM/link dp1 tm1)
  ask (HVM/link dp2 tm2)
  ret #Unit
}
| #DUP dup_lab dup_loc #LAM lam_lab lam_loc = do HVM {
  log "DUP-LAM"
  ask dp1 = (HVM/take (HVM/at 1 dup_loc))
  ask dp2 = (HVM/take (HVM/at 2 dup_loc))
  ask var = (HVM/take (HVM/at 1 lam_loc))
  ask bod = (HVM/take (HVM/at 2 lam_loc))
  ask co1 = (HVM/alloc-node 3)
  ask co2 = (HVM/alloc-node 3)
  ask du1 = (HVM/alloc-node 3)
  ask du2 = (HVM/alloc-node 3)
  ask (HVM/set (HVM/at 1 co1) (#RTerm{ #SUB 0 (HVM/at 1 co1) }))
  ask (HVM/set (HVM/at 2 co1) (#RTerm{ #VAR 0 (HVM/at 1 du2) }))
  ask (HVM/set (HVM/at 1 co2) (#RTerm{ #SUB 0 (HVM/at 1 co2) }))
  ask (HVM/set (HVM/at 2 co2) (#RTerm{ #VAR 0 (HVM/at 2 du2) }))
  ask (HVM/set (HVM/at 1 du1) (#RTerm{ #VAR 0 (HVM/at 1 co1) }))
  ask (HVM/set (HVM/at 2 du1) (#RTerm{ #VAR 0 (HVM/at 1 co2) }))
  ask (HVM/set (HVM/at 1 du2) (#RTerm{ #SUB 0 (HVM/at 1 du2) }))
  ask (HVM/set (HVM/at 2 du2) (#RTerm{ #SUB 0 (HVM/at 2 du2) }))
  ask (HVM/link dp1 (#RTerm{ #LAM 0 co1 }))
  ask (HVM/link dp2 (#RTerm{ #LAM 0 co2 }))
  ask (HVM/link var (#RTerm{ #SUP 0 du1 }))
  ask (HVM/link (#RTerm{ #DUP 0 du2 }) bod)
  ret #Unit
}
| #DUP dup_lab dup_loc #NUL nul_lab nul_loc = do HVM {
  log "DUP-NUL"
  ask dp1 = (HVM/take (HVM/at 1 dup_loc))
  ask dp2 = (HVM/take (HVM/at 2 dup_loc))
  ask (HVM/link dp1 (#RTerm{ #NUL 0 0 }))
  ask (HVM/link dp2 (#RTerm{ #NUL 0 0 }))
  ret #Unit
}
| #ERA era_lab era_loc #LAM lam_lab lam_loc = do HVM {
  log "ERA-LAM"
  ask var = (HVM/take (HVM/at 1 lam_loc))
  ask bod = (HVM/take (HVM/at 2 lam_loc))
  ask (HVM/link var (#RTerm{ #NUL 0 0 }))
  ask (HVM/link (#RTerm{ #ERA 0 0 }) bod)
  ret #Unit
}
| #ERA era_lab era_loc #SUP sup_lab sup_loc = do HVM {
  log "ERA-SUP"
  ask tm1 = (HVM/take (HVM/at 1 sup_loc))
  ask tm2 = (HVM/take (HVM/at 2 sup_loc))
  ask (HVM/link (#RTerm{ #ERA 0 0 }) tm1)
  ask (HVM/link (#RTerm{ #ERA 0 0 }) tm2)
  ret #Unit
}
| #ERA era_lab era_loc #NUL nul_lab nul_loc = do HVM {
  log "ERA-NUL"
  ret #Unit
}
| at ak al bt bk bl = do HVM {
  ret #Unit
}

// Evaluation
// ----------

HVM/eval-one : (HVM Bool)
= do HVM {
  ask redex = HVM/pop-redex
  match redex {
    #Some{neg_pos}:
      let #RRedex{neg pos} = neg_pos
      do HVM {
        //log #RULE{a b}
        ask (HVM/interact neg pos)
        ret #True
      }
    #None: do HVM {
      ret #False
    }
  }
}

HVM/eval-strict : (HVM Unit)
= λnet match (HVM/eval-one net) {
  #Pair{net changed}: match changed {
    #True: (HVM/eval-strict net)
    #False: #Pair{net #Unit}
  }
}

// Main
// ----

// include comments and everything

main
: String/View
= (HVM/run _ do HVM {

  // not^(2^4)(true) - 264 ITRS
  use f4 = "q
    & ((p (* p)) q) ~ (m o)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
  "

  // not^(2^8)(true) - 4120 ITRS
  use f8 = "cb
    & ((bb (* bb)) cb) ~ (y ab)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
  "

  // not^(2^12)(true) - 65576 ITRS
  use fC = "ob
    & ((nb (* nb)) ob) ~ (kb mb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
  "

  // not^(2^14)(true) - 262192 ITRS
  use fC = "ub
    & ((tb (* tb)) ub) ~ (qb sb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
    & {(ob pb) (nb ob)} ~ (kb mb)
    & {(rb sb) (qb rb)} ~ (nb pb)"

  // not^(2^16)(true) - 1048632 ITRS
  use fG = "ac
    & ((zb (* zb)) ac) ~ (wb yb)
    & {(e f) (d e)} ~ (((* (a a)) ((b (* b)) c)) c)
    & {(h i) (g h)} ~ (d f)
    & {(k l) (j k)} ~ (g i)
    & {(n o) (m n)} ~ (j l)
    & {(q r) (p q)} ~ (m o)
    & {(t u) (s t)} ~ (p r)
    & {(w x) (v w)} ~ (s u)
    & {(z ab) (y z)} ~ (v x)
    & {(cb db) (bb cb)} ~ (y ab)
    & {(fb gb) (eb fb)} ~ (bb db)
    & {(ib jb) (hb ib)} ~ (eb gb)
    & {(lb mb) (kb lb)} ~ (hb jb)
    & {(ob pb) (nb ob)} ~ (kb mb)
    & {(rb sb) (qb rb)} ~ (nb pb)
    & {(ub vb) (tb ub)} ~ (qb sb)
    & {(xb yb) (wb xb)} ~ (tb vb)
  "

  // Boots Net
  ask (HVM/boot (HVM/do-parse-net f8))

  // Normalizes
  ask HVM/eval-strict

  // Results
  ask net  = HVM/get-net
  ask rnet = HVM/get-rnet
  ask itrs = HVM/get-itrs

  // Logs
  log "[ITRS]"
  log (U64/to-string itrs)
  log "[NET]"
  log (HVM/Net/to-string net)
  log "[RNET]"
  log (HVM/RNet/to-string rnet)

  // Returns result
  ret #View{"ok"}
})
