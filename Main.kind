Foo : ∀(x: (Maybe (Pair U64 U64))) U64
= λx match x {
  #Some{pair}: match pair {
    #Pair{a b}: match (U64/is-zero a) {
      #True: (Foo x)
      #False: 0
    }
  }
  #None: 0
}





//Foo : ∀(m: Nat) ∀(n: Nat) Bool
//| #Zero    #Zero    = #True
//| #Succ{m} #Succ{n} = (Foo m n)
//| x        y        = #False

//Bar : U64 -> U64 -> U64 -> U64
//| a b c = a

//double : ∀(n: Nat) ∀(r: Nat) Nat
//| n r = match n {
  //#Zero: r
  //#Succ: λnp (double np #Succ{#Succ{r}})
//}
//main : Nat = (double #20 #0)


//double : ∀(n: U64) ∀(r: U64) U64
//= λn λr
  //switch n {
    //0: r
    //_{pred}: (double pred (+ r 2))
  //}

//main : U64 = (double 1000000 0)





//Main : (Pair String *) -> (Pair (List U64) *)
//| str = str

//main : String/View
//= #View { "// Comment 1\/ Comment 2\nabc" }


//main = Parser/parse-unicode-escape






//main : (Pair/Pair U64 U64)
//= #Pair { foo 13 }

//use Bool/ as Bool/
//use U64/ as U64/
//use Parser/ as Parser/
//use Pair/ as Pair/

//foo : (Pair/Parser Unit) = ?oxi

//affer : (Parser/Parser U64)
//= when U64/eq 50 {
  //'(' : do Parser/Monad {
    //ask foo
    //ret 12
  //}
  //'{' : ?b
  //'*' : ?c
  //_   : ?d
//}

//main : U64
//= when U64/eq 35 {
  //0  : 0
  //10 : 100
  //20 : 200
  //30 : 300
  //_  : 999
//}

//use Bool/ as Bool/

//Foo : Bool -> Bool
//| #True = #False
//| other   = #True

//Main : Bool
//= (Foo #False)

//| #True = ?a

//use Nat/ as Nat/
//use String/ as String/

//Main
//: String/View
//= #View{ "\nI'm a (λx x) \nThat's nice!\n" }

//use Block/ as BK/
//use Bool/ as Bool/
//use Empty/ as EM/
//use Equal/ as EQ/
//use Maybe/ as MB/
//use Pair/ as Pair/
//use / as /

//IsTrue
//: ∀(b: Bool)
  //*
//= λb data[b]{
  //#Indeed : (IsTrue #True)
//}

//Main
//: ∀(x: Bool)
  //∀(t: (IsTrue x))
  //Bool
//= λ{
  //#True: λ{
    //#Indeed: #True
  //}
  //#False: λ{
    //#Indeed: #void
  //}
//}

//Main
//: ∀(p: (Pair U64 Bool))
  //∀(k: (Maybe (Pair U64 Bool)))
  //(Maybe U64)
//= λp λk do Maybe {
  //ask x = #Some{50}
  //ask y = #Some{20}
  //ret (+ x y)
//}

//use Maybe/ as Maybe/

//Main
//: (Maybe U64)
//= do Maybe/Monad/ {
  //ask x = #Some { 50 }
  //ask y = #Some { 20 }
  //ret ?a
//}

//use List/ as List/
//use Nat/ as Nat/
//use String/ as String/

//Main
//: String
//= "foo bar"

//use Pair/ as Pair/
//use Bool/ as Bool/

//Main
//: ∀(f: ∀(x: Bool) Bool)
  //Nat
//= λf match (f #True) {
  //#True: ?a
  //#False: ?b
//}

////∀(fx: Bool) (P 

//Aux
//: ∀(P: ∀(x: Bool) *)
  //∀(Fx: Bool)
  //(P Fx)
//= λP λ{
  //#True: ?t
  //#False: ?f
//}
  







//ct0 = λx match x {
  //#Succ: λm λx match x {
    //#Succ: λn ((Foo m) n)
    //#_: λy #False{}
  //}
  //#Zero: λx match x {
    //#Zero:#True{}
    //#_:λy #False{}
  //}
  //#_:*
//}

//ct1 = λm λn λv2 λv3 match m {#Succ:λm match n {#Succ:λn ((Foo m) n) #_:#False{} } #Zero:match n {#Zero:#True{} #_:#False{} } #_:* }





//pull λx match x {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* } ### dep=0 ari=0 skp=0
//pull match m {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* } ### dep=1 ari=1 skp=0
//pull λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=1 ari=1 skp=1
//pull λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=2 ari=1 skp=0
//pull match n {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=3 ari=2 skp=0
//pull λn ((Foo m) n) ### dep=3 ari=2 skp=1
//pull ((Foo m) n) ### dep=4 ari=2 skp=0
//pull λy #False{} ### dep=3 ari=2 skp=1
//pull #False{} ### dep=4 ari=2 skp=0
//WARNING: inconsistent cross-branch lambda count on: match n {#Succ:λn ((Foo m) n) #_:λy #False{} }
//pull λx match x {#Zero:#True{} #_:λy #False{} } ### dep=1 ari=1 skp=0
//pull match n {#Zero:#True{} #_:λy #False{} } ### dep=2 ari=2 skp=0
//pull #True{} ### dep=2 ari=2 skp=0
//pull λy #False{} ### dep=2 ari=2 skp=1
//pull #False{} ### dep=3 ari=2 skp=0
//WARNING: inconsistent cross-branch lambda count on: match m {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* }
//pull * ### dep=1 ari=1 skp=1
//ct0 = λx match x {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* }
//ct1 = λm λn λv2 λv3 match m {#Succ:λm match n {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:match n {#Zero:#True{} #_:λy #False{} } #_:* }
//pull ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } }) ### dep=0 ari=0 skp=0
//ct0 = ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } })
//ct1 = ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } })
