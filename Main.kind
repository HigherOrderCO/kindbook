use Pair/ as P/

main : (P/Pair U32 U32)
= #Pair { foo 13 }






//use Bool/ as B/
//use U32/ as U32/
//use Parser/ as PS/
//use Pair/ as P/

//foo : (P/Parser U/Unit) = ?oxi


//affer : (PS/Parser U32)
//= when U32/eq 50 {
  //'(' : do Parser/Monad {
    //ask foo
    //ret 12
  //}
  //'{' : ?b
  //'*' : ?c
  //_   : ?d
//}


//main : U32
//= when U32/eq 35 {
  //0  : 0
  //10 : 100
  //20 : 200
  //30 : 300
  //_  : 999
//}


//use Bool/ as B/

//Foo : B/Bool -> B/Bool
//| #True{} = #False
//| other   = #True

//Main : B/Bool
//= (Foo #False{})



//| #True{} = ?a



//use Nat/ as N/
//use String/ as S/

//Main
//: S/View
//= #View{ "\nI'm a (λx x) \nThat's nice!\n" }

//use Block/ as BK/
//use Bool/ as B/
//use Empty/ as EM/
//use Equal/ as EQ/
//use Maybe/ as MB/
//use Pair/ as P/
//use Trait/ as T/

//IsTrue
//: ∀(b: B/Bool)
  //*
//= λb data[b]{
  //#Indeed{} : (IsTrue #True)
//}

//Main
//: ∀(x: B/Bool)
  //∀(t: (IsTrue x))
  //B/Bool
//= λ{
  //#True: λ{
    //#Indeed: #True
  //}
  //#False: λ{
    //#Indeed: #void
  //}
//}

//Main
//: ∀(p: (P/Pair U32 B/Bool))
  //∀(k: (MB/Maybe (P/Pair U32 B/Bool)))
  //(MB/Maybe U32)
//= λp λk do MB/Monad {
  //ask x = #Some{50}
  //?a
  ////ask y = #Some{20}
  ////ret (+ x y)
//}








//use Maybe/ as M/

//Main
//: (M/Maybe U32)
//= do M/Monad/ {
  //ask x = #Some { 50 }
  //ask y = #Some { 20 }
  //ret ?a
//}

//use List/ as L/
//use Nat/ as N/
//use String/ as S/

//Main
//: S/String
//= "foo bar"





//use Pair/ as P/
//use Bool/ as B/

//Main
//: ∀(f: ∀(x: B/Bool) B/Bool)
  //N/Nat
//= λf match (f #True{}) {
  //#True: ?a
  //#False: ?b
//}



////∀(fx: B/Bool) (P 

//Aux
//: ∀(P: ∀(x: B/Bool) *)
  //∀(Fx: B/Bool)
  //(P Fx)
//= λP λ{
  //#True: ?t
  //#False: ?f
//}
  




