main : (Pair/Pair U32 U32)
= #Pair { foo 13 }

//use Bool/ as Bool/
//use U32/ as U32/
//use Parser/ as Parser/
//use Pair/ as Pair/

//foo : (Pair/Parser Unit/Unit) = ?oxi

//affer : (Parser/Parser U32)
//= when U32/eq 50 {
  //'(' : do Parser/Monad {
    //ask foo
    //ret 12
  //}
  //'{' : ?b
  //'*' : ?c
  //_   : ?d
//}

//main : U32
//= when U32/eq 35 {
  //0  : 0
  //10 : 100
  //20 : 200
  //30 : 300
  //_  : 999
//}

//use Bool/ as Bool/

//Foo : Bool/Bool -> Bool/Bool
//| #True{} = #False
//| other   = #True

//Main : Bool/Bool
//= (Foo #False{})

//| #True{} = ?a

//use Nat/ as Nat/
//use String/ as String/

//Main
//: String/View
//= #View{ "\nI'm a (λx x) \nThat's nice!\n" }

//use Block/ as BK/
//use Bool/ as Bool/
//use Empty/ as EM/
//use Equal/ as EQ/
//use Maybe/ as MB/
//use Pair/ as Pair/
//use Trait/ as Trait/

//IsTrue
//: ∀(b: Bool/Bool)
  //*
//= λb data[b]{
  //#Indeed{} : (IsTrue #True)
//}

//Main
//: ∀(x: Bool/Bool)
  //∀(t: (IsTrue x))
  //Bool/Bool
//= λ{
  //#True: λ{
    //#Indeed: #True
  //}
  //#False: λ{
    //#Indeed: #void
  //}
//}

//Main
//: ∀(p: (Pair/Pair U32 Bool/Bool))
  //∀(k: (MB/Maybe (Pair/Pair U32 Bool/Bool)))
  //(MB/Maybe U32)
//= λp λk do MB/Monad {
  //ask x = #Some{50}
  //?a
  ////ask y = #Some{20}
  ////ret (+ x y)
//}

//use Maybe/ as Maybe/

//Main
//: (Maybe/Maybe U32)
//= do Maybe/Monad/ {
  //ask x = #Some { 50 }
  //ask y = #Some { 20 }
  //ret ?a
//}

//use List/ as List/
//use Nat/ as Nat/
//use String/ as String/

//Main
//: String/String
//= "foo bar"

//use Pair/ as Pair/
//use Bool/ as Bool/

//Main
//: ∀(f: ∀(x: Bool/Bool) Bool/Bool)
  //Nat/Nat
//= λf match (f #True{}) {
  //#True: ?a
  //#False: ?b
//}

////∀(fx: Bool/Bool) (P 

//Aux
//: ∀(P: ∀(x: Bool/Bool) *)
  //∀(Fx: Bool/Bool)
  //(P Fx)
//= λP λ{
  //#True: ?t
  //#False: ?f
//}
  

