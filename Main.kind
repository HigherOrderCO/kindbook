//Main : ∀(str: String) Char
//= λstr match str {
  //#Cons{h t}: h
  //#Nil: 'a'
//}




main : ∀(b: Bool) U64
= λb
  let x = match b { #True: 0 #False: 1 } :: U64
  x







// TODO: inspired on double, create a fib function with U64 inputs
// it must be a tail recursive function
// remember the switch syntax is:
// switch n { 0: ... _{np}: ... } // here, np is n-1
// it can NOT have more than 2 cases.

//o bλ__0 match __0 {#Pair:λ__0 match __0 {#A:λv 5 #B:λv 6 } }
//~λx0 match x0 {#Pair:λ__0 match __0 {#A:λv 5 #B:λv 6 } }

//~λ__0 match __0 {#Pair:λ__0 match __0 {#A:λv 5 #B:λv 6 } }
//~λx0 match x0 {#Pair:λfst0 λsnd1 match fst0 {#A:5 #B:6 } }

//main : Bool = (String/eq "(" ")")

//main : Bits = (String/to-bits "o")
//main : Bits = (Bits/concat [#O{#I{#E}} #I{#O{#E}}])


//main : ∀(x: (Pair U64 U64)) (Pair U64 U64)
//| state =
  //let #Pair{input index} = state
  //#Pair{input index}


//data T {
  //#A
  //#B
//}

//// \/ TODO: this compiles worse. investigate
//Foo : ∀(x: (Pair T U64)) U64
//| #Pair{#A v} = v
//| #Pair{#B v} = v

//Foo : ∀(x: (Pair T T)) U64
//= λx match x {
  //#Pair{k v}: match k {
    //#A: 5
    //#B: 6
  //}
//}

//main : U64 = (Foo #Pair{#A 5})



//fib/go : ∀(n: U64) ∀(a: U64) ∀(b: U64) U64
//= λn λa λb
  //switch n {
    //0: a
    //_{pred}: (fib/go pred b (+ a b))
  //}

//// create fib now
//fib : ∀(n: U64) U64
//= λn (fib/go n 0 1)

//// create a main
//main : U64
//= let x = (fib/go 0)
  //let y = (fib/go 0 0)
  //let z = (fib/go 0 0 0)
  //(fib 1000000)



//Foo : ∀(x: (Maybe (Pair U64 U64))) U64
//= λx match x {
  //#Some{pair}: match pair {
    //#Pair{a b}: match (U64/is-zero a) {
      //#True: (Foo x)
      //#False: 0
    //}
  //}
  //#None: 0
//}


//main : (Maybe U64)
//= do Maybe {
  //ask x = #Some{1}
  //ask y = #Some{2}
  //ret (+ x y)
//}



//Foo : ∀(m: Nat) ∀(n: Nat) Bool
//| #Zero    #Zero    = #True
//| #Succ{m} #Succ{n} = (Foo m n)
//| x        y        = #False

//Bar : U64 -> U64 -> U64 -> U64
//| a b c = a

//double : ∀(n: Nat) ∀(r: Nat) Nat
//| n r = match n {
  //#Zero: r
  //#Succ: λnp (double np #Succ{#Succ{r}})
//}
//main : Nat = (double #20 #0)


//double : ∀(n: U64) ∀(r: U64) U64
//= λn λr
  //switch n {
    //0: r
    //_{pred}: (double pred (+ r 2))
  //}

//main : U64 = (double 1000000 0)





//Main : (Pair String *) -> (Pair (List U64) *)
//| str = str

//main : String/View
//= #View { "// Comment 1\/ Comment 2\nabc" }


//main = Parser/parse-unicode-escape






//main : (Pair/Pair U64 U64)
//= #Pair { foo 13 }

//use Bool/ as Bool/
//use U64/ as U64/
//use Parser/ as Parser/
//use Pair/ as Pair/

//foo : (Pair/Parser Unit) = ?oxi

//affer : (Parser/Parser U64)
//= when U64/eq 50 {
  //'(' : do Parser/Monad {
    //ask foo
    //ret 12
  //}
  //'{' : ?b
  //'*' : ?c
  //_   : ?d
//}

//main : U64
//= when U64/eq 35 {
  //0  : 0
  //10 : 100
  //20 : 200
  //30 : 300
  //_  : 999
//}

//use Bool/ as Bool/

//Foo : Bool -> Bool
//| #True = #False
//| other   = #True

//Main : Bool
//= (Foo #False)

//| #True = ?a

//use Nat/ as Nat/
//use String/ as String/

//Main
//: String/View
//= #View{ "\nI'm a (λx x) \nThat's nice!\n" }

//use Block/ as BK/
//use Bool/ as Bool/
//use Empty/ as EM/
//use Equal/ as EQ/
//use Maybe/ as MB/
//use Pair/ as Pair/
//use / as /

//IsTrue
//: ∀(b: Bool)
  //*
//= λb data[b]{
  //#Indeed : (IsTrue #True)
//}

//Main
//: ∀(x: Bool)
  //∀(t: (IsTrue x))
  //Bool
//= λ{
  //#True: λ{
    //#Indeed: #True
  //}
  //#False: λ{
    //#Indeed: #void
  //}
//}

//Main
//: ∀(p: (Pair U64 Bool))
  //∀(k: (Maybe (Pair U64 Bool)))
  //(Maybe U64)
//= λp λk do Maybe {
  //ask x = #Some{50}
  //ask y = #Some{20}
  //ret (+ x y)
//}

//use Maybe/ as Maybe/

//Main
//: (Maybe U64)
//= do Maybe/Monad/ {
  //ask x = #Some { 50 }
  //ask y = #Some { 20 }
  //ret ?a
//}

//use List/ as List/
//use Nat/ as Nat/
//use String/ as String/

//Main
//: String
//= "foo bar"

//use Pair/ as Pair/
//use Bool/ as Bool/

//Main
//: ∀(f: ∀(x: Bool) Bool)
  //Nat
//= λf match (f #True) {
  //#True: ?a
  //#False: ?b
//}

////∀(fx: Bool) (P 

//Aux
//: ∀(P: ∀(x: Bool) *)
  //∀(Fx: Bool)
  //(P Fx)
//= λP λ{
  //#True: ?t
  //#False: ?f
//}
  







//ct0 = λx match x {
  //#Succ: λm λx match x {
    //#Succ: λn ((Foo m) n)
    //#_: λy #False{}
  //}
  //#Zero: λx match x {
    //#Zero:#True{}
    //#_:λy #False{}
  //}
  //#_:*
//}

//ct1 = λm λn λv2 λv3 match m {#Succ:λm match n {#Succ:λn ((Foo m) n) #_:#False{} } #Zero:match n {#Zero:#True{} #_:#False{} } #_:* }





//pull λx match x {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* } ### dep=0 ari=0 skp=0
//pull match m {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* } ### dep=1 ari=1 skp=0
//pull λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=1 ari=1 skp=1
//pull λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=2 ari=1 skp=0
//pull match n {#Succ:λn ((Foo m) n) #_:λy #False{} } ### dep=3 ari=2 skp=0
//pull λn ((Foo m) n) ### dep=3 ari=2 skp=1
//pull ((Foo m) n) ### dep=4 ari=2 skp=0
//pull λy #False{} ### dep=3 ari=2 skp=1
//pull #False{} ### dep=4 ari=2 skp=0
//WARNING: inconsistent cross-branch lambda count on: match n {#Succ:λn ((Foo m) n) #_:λy #False{} }
//pull λx match x {#Zero:#True{} #_:λy #False{} } ### dep=1 ari=1 skp=0
//pull match n {#Zero:#True{} #_:λy #False{} } ### dep=2 ari=2 skp=0
//pull #True{} ### dep=2 ari=2 skp=0
//pull λy #False{} ### dep=2 ari=2 skp=1
//pull #False{} ### dep=3 ari=2 skp=0
//WARNING: inconsistent cross-branch lambda count on: match m {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* }
//pull * ### dep=1 ari=1 skp=1
//ct0 = λx match x {#Succ:λm λx match x {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:λx match x {#Zero:#True{} #_:λy #False{} } #_:* }
//ct1 = λm λn λv2 λv3 match m {#Succ:λm match n {#Succ:λn ((Foo m) n) #_:λy #False{} } #Zero:match n {#Zero:#True{} #_:λy #False{} } #_:* }
//pull ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } }) ### dep=0 ari=0 skp=0
//ct0 = ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } })
//ct1 = ((Foo #Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } }) #Succ{pred:#Succ{pred:#Succ{pred:#Succ{pred:#Zero{} } } } })
