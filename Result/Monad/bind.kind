use Result/ as R/

// Applies a function to the value inside a Result, if it's successful.
// - 1st: The type of the value in the input Result.
// - 2nd: The type of the value in the output Result.
// - 3rd: The type of the error.
// - 4th: The Result value to operate on.
// - 5th: The function to apply to the value inside the Result if it's successful.
// = A new Result value resulting from applying 2nd to the contents of 1st if successful,
//   or the original error if 1st is a failure.
R/Monad/bind
: ∀(A: *)
  ∀(B: *)
  ∀(E: *)
  ∀(ra: (R/Result A E))
  ∀(fn: ∀(a: A) (R/Result B E))
  (R/Result B E)
= λA λB λE λ{
  #Done: λra.value λfn (fn ra.value)
  #Fail: λra.error λfn #Fail{ra.error}
}
//TEST//

use Result/ as R/
use Equal/ as E/
use Nat/ as N/
// use String/ as S/

// // Test: Applying bind to a failed Result returns the same Fail.
// T0
// : (E/Equal (R/Result U32 S/String) (R/Monad/bind U32 U32 S/String (#Fail{"Error"}) (λx #Done{(+ x 5)})) (#Fail{"Error"}))
// = #Refl{}

// Test: Applying a function to a failure should return the same Fail value.
T1
: (E/Equal (R/Result U32 U32) (R/Monad/bind U32 U32 U32 (#Fail{10}) (λx #Done{(+ x 1)})) (#Fail{10}))
= #Refl{}

// Test: Chain binds where the first result is a Fail.
T2
: (E/Equal (R/Result U32 U32) (R/Monad/bind U32 U32 U32 (#Fail{7}) (λx (R/Monad/bind U32 U32 U32 (#Done{(+ x 2)}) (λy #Done{(* y 2)})))) (#Fail{7}))
= #Refl{}

// Test: Chain binds where the second result is a Fail.
T3
: (E/Equal (R/Result U32 U32) (R/Monad/bind U32 U32 U32 (#Done{3}) (λx (R/Monad/bind U32 U32 U32 (#Fail{8}) (λy #Done{(* y 2)})))) (#Fail{8}))
= #Refl{}