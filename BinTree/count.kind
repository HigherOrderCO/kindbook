// Counts the occurrences of a given value in a binary tree.
// - A: The type of elements in the tree.
// - e: An equality instance for type A.
// - x: The value to count.
// - t: The binary tree to search.
// = The number of occurrences of the given value in the tree.
BinTree/count : âˆ€(A: *) (Trait/Eq A) -> A -> (BinTree/BinTree A) -> Nat
| A e x #Leaf = #Zero
| A e x #Node{val lft rgt} =
  let is_equal  = (Trait/Eq/eq A e x val)
  let count_val = (Bool/if Nat is_equal #Succ{#Zero} #Zero)
  let count_lft = (BinTree/count A e x lft)
  let count_rgt = (BinTree/count A e x rgt)
  (Nat/add count_val (Nat/add count_lft count_rgt))

// Test: Count in an empty tree
TEST_0
: (Equal 
		Nat 
		(BinTree/count 
			Nat 
			NT/Eq 
			(#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}) 
			#Leaf{}) 
		#Zero{})
= #Refl{}

// Test: Count in a tree with one matching element
TEST_1
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
      (#Node{
        (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
        #Leaf{}
        #Leaf{}
      })
    )
    (#Succ{#Zero{}})
  )
= #Refl{}

// Test: Count in a tree with multiple matching elements
TEST_2
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
      (#Node{
        (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
        (#Node{
          (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
          #Leaf{}
          #Leaf{}
        })
        (#Node{
          (#Succ{#Succ{#Succ{#Zero{}}}})
          #Leaf{}
          (#Node{
            (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
            #Leaf{}
            #Leaf{}
          })
        })
      })
    )
    (#Succ{#Succ{#Succ{#Zero{}}}})
  )
= #Refl{}

// Test: Count in a tree with no matching elements
TEST_3
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}})
      (#Node{
        (#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
        (#Node{
          (#Succ{#Succ{#Succ{#Zero{}}}})
          #Leaf{}
          #Leaf{}
        })
        (#Node{
          (#Succ{#Zero{}})
          #Leaf{}
          (#Node{
            (#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}})
            #Leaf{}
            #Leaf{}
          })
        })
      })
    )
    #Zero{}
  )
= #Refl{}

// Test: Count in a balanced tree with mixed elements
TEST_4
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Succ{#Zero{}}})
      (#Node{
        (#Succ{#Zero{}})
        (#Node{
          (#Succ{#Succ{#Zero{}}})
          #Leaf{}
          #Leaf{}
        })
        (#Node{
          (#Succ{#Succ{#Succ{#Zero{}}}})
          (#Node{
            (#Succ{#Succ{#Zero{}}})
            #Leaf{}
            #Leaf{}
          })
          (#Node{
            (#Succ{#Succ{#Succ{#Succ{#Zero{}}}}})
            #Leaf{}
            #Leaf{}
          })
        })
      })
    )
    (#Succ{#Succ{#Zero{}}})
  )
= #Refl{}

// Test: Count in a left-heavy tree
TEST_5
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Zero{}})
      (#Node{
        (#Succ{#Zero{}})
        (#Node{
          (#Succ{#Zero{}})
          (#Node{
            (#Succ{#Zero{}})
            #Leaf{}
            #Leaf{}
          })
          #Leaf{}
        })
        #Leaf{}
      })
    )
    (#Succ{#Succ{#Succ{#Zero{}}}}))
= #Refl{}

// Test: Count in a right-heavy tree
TEST_6
: (Equal
    Nat
    (BinTree/count
      Nat
      NT/Eq
      (#Succ{#Succ{#Succ{#Zero{}}}})
      (#Node{
        (#Succ{#Zero{}})
        #Leaf{}
        (#Node{
          (#Succ{#Succ{#Zero{}}})
          #Leaf{}
          (#Node{
            (#Succ{#Succ{#Succ{#Zero{}}}})
            #Leaf{}
            (#Node{
              (#Succ{#Succ{#Succ{#Zero{}}}})
              #Leaf{}
              #Leaf{}
            })
          })
        })
      })
    )
    (#Succ{#Succ{#Zero{}}})
  )
= #Refl{}
