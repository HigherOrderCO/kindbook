use BinTree/ as BT/

// Merges two trees using combining functions.
// - 1st: The type of elements in the first tree.
// - 2nd: The type of elements in the second tree.
// - 3th: The type of elements in the resulting tree.
// - 4th: Function to handle cases where only the first tree has a value.
// - 5th: Function to handle cases where only the second tree has a value.
// - 6th: Function to combine values when both trees have a value.
// - 7th: The first input tree.
// - 8th: The second input tree.
// = A new tree where each node is the result of applying the appropriate
//   function based on the presence of values in both input trees.
BT/merge
: ∀(A: *)
  ∀(B: *)
  ∀(C: *)
  ∀(a: ∀(x: A) C)
  ∀(b: ∀(x: B) C)
  ∀(ab: ∀(x: A) ∀(y: B) C)
  ∀(t1: (BT/BinTree A))
  ∀(t2: (BT/BinTree B))
  (BT/BinTree C)
= λA λB λC λa λb λab λ{
  #Leaf: λ{
    #Leaf: #Leaf{}
    #Node: λt2.val λt2.lft λt2.rgt
      #Node{
        val: (b t2.val)
        lft: (BT/merge A B C a b ab #Leaf{} t2.lft)
        rgt: (BT/merge A B C a b ab #Leaf{} t2.rgt)
      }
  }
  #Node: λt1.val λt1.lft λt1.rgt λ{
    #Leaf:
      #Node{
        val: (a t1.val)
        lft: (BT/merge A B C a b ab t1.lft #Leaf{})
        rgt: (BT/merge A B C a b ab t1.rgt #Leaf{})
      }
    #Node: λt2.val λt2.lft λt2.rgt
      #Node{
        val: (ab t1.val t2.val)
        lft: (BT/merge A B C a b ab t1.lft t2.lft)
        rgt: (BT/merge A B C a b ab t1.rgt t2.rgt)
      }
  }
}

//TEST//

use BinTree/ as BT/
use U32/ as U32/
use Bool/ as B/
use Equal/ as E/
use Function/ as F/

// Test: Merging two empty trees
T0 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/add #Leaf{} #Leaf{}) #Leaf{})
= #Refl{}

// Test: Merging an empty tree with a non-empty tree
T1 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/add #Leaf{} #Node{5 #Leaf{} #Leaf{}}) #Node{5 #Leaf{} #Leaf{}})
= #Refl{}

// Test: Merging a non-empty tree with an empty tree
T2 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/add #Node{3 #Leaf{} #Leaf{}} #Leaf{}) #Node{3 #Leaf{} #Leaf{}})
= #Refl{}

// Test: Merge two non-empty trees
T3 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/add #Node{2 #Leaf{} #Leaf{}} #Node{3 #Leaf{} #Leaf{}}) #Node{5 #Leaf{} #Leaf{}})
= #Refl{}

// Test: Merging two more complex trees
T4 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/add #Node{1 #Node{2 #Leaf{} #Leaf{}} #Leaf{}} #Node{3 #Leaf{} #Node{4 #Leaf{} #Leaf{}}}) #Node{4 #Node{2 #Leaf{} #Leaf{}} #Node{4 #Leaf{} #Leaf{}}})
= #Refl{}

// Test: Merging trees with a different merge function (max)
T5 
: (E/Equal _ (BT/merge _ _ _ (F/id _) (F/id _) U32/max #Node{5 #Node{3 #Leaf{} #Leaf{}} #Node{7 #Leaf{} #Leaf{}}} #Node{4 #Node{6 #Leaf{} #Leaf{}} #Node{2 #Leaf{} #Leaf{}}}) #Node{5 #Node{6 #Leaf{} #Leaf{}} #Node{7 #Leaf{} #Leaf{}}})
= #Refl{}

// Test: Merging trees with custom functions for single-tree nodes
T6 
: (E/Equal _ (BT/merge _ _ _ (λx (U32/add x 1)) (λx (U32/mul x 2)) U32/add #Node{3 #Leaf{} #Node{2 #Leaf{} #Leaf{}}} #Node{1 #Node{4 #Leaf{} #Leaf{}} #Leaf{}}) #Node{4 #Node{8 #Leaf{} #Leaf{}} #Node{3 #Leaf{} #Leaf{}}})
= #Refl{}

// Test: Merge trees with different types
T7 
: (E/Equal _ (BT/merge _ _ _ (λx (B/if N/Nat x 1 0)) (F/id _) (λx λy (B/if N/Nat x (U32/add y 1) y)) #Node{#True{} #Leaf{} #Leaf{}} #Node{5 #Leaf{} #Leaf{}}) #Node{6 #Leaf{} #Leaf{}})
= #Refl{}
