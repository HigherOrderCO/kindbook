// Dependent eliminator for binary trees.
// - A: The type of elements in the tree.
// - P: The motive (type family) for the elimination.
// - leaf: The result for the leaf case.
// - node: The function to apply for the node case.
// - tree: The tree to eliminate (scrutinee).
// = The result of the elimination, whose type depends on the input tree.
BinTree/match
: ∀(A: *)
  ∀(P: ∀(tree: (BinTree/BinTree A)) *)
  ∀(leaf: (P #Leaf{}))
  ∀(node: ∀(val: A)
          ∀(lft: (BinTree/BinTree A))
          ∀(rgt: (BinTree/BinTree A))
          ∀(p_lft: (P lft))
          ∀(p_rgt: (P rgt))
          (P (#Node{val lft rgt})))
  ∀(tree: (BinTree/BinTree A))
  (P tree)
= λA λP λleaf λnode λ{
  #Leaf: leaf
  #Node: λtree.val λtree.lft λtree.rgt
    (node
      tree.val
      tree.lft
      tree.rgt
      (BinTree/match A P leaf node tree.lft)
      (BinTree/match A P leaf node tree.rgt))
}

// Test cases for BinTree match function

// Counts the number of nodes in a binary tree
count-nodes
: ∀(A: *)
  ∀(tree: (BinTree/BinTree A))
  Nat/Nat
= λA λtree
  (BinTree/match A (λx Nat/Nat) #Zero{} (λval λlft λrgt λl λr #Succ{(Nat/add l r)}) tree)

// Test: Counting nodes
TEST_0
: (Equal/Equal
    Nat/Nat
    (count-nodes
      Nat/Nat
      (#Node{
        #Zero{}
        (#Node{#Zero{} #Leaf{} #Leaf{}})
        (#Node{#Zero{} #Leaf{} (#Node{#Zero{} #Leaf{} #Leaf{}})})
      }))
    #Succ{#Succ{#Succ{#Succ{#Zero{}}}}}
  )
= #Refl{}

// Calculates the depth of a binary tree
tree-depth
: ∀(A: *)
  ∀(tree: (BinTree/BinTree A))
  Nat/Nat
= λA λtree
  (BinTree/match A (λx Nat/Nat) #Zero{} (λval λlft λrgt λl λr #Succ{(Nat/max l r)}) tree)

// Test: Tree depth
TEST_1
: (Equal/Equal
    Nat/Nat
    (tree-depth
      Nat/Nat
      (#Node{
        #Zero{}
        (#Node{#Zero{} #Leaf{} #Leaf{}})
        (#Node{#Zero{} #Leaf{} (#Node{#Zero{} #Leaf{} #Leaf{}})})
      }))
    #Succ{#Succ{#Succ{#Zero{}}}}
  )
= #Refl{}

// Counts the number of leaves in a binary tree
leaf-count
: ∀(A: *)
  ∀(tree: (BinTree/BinTree A))
  Nat/Nat
= λA λtree
  (BinTree/match A (λx Nat/Nat) #Succ{#Zero{}} (λval λlft λrgt λl λr (Nat/add l r)) tree)

// Test: Leaf count
TEST_2
: (Equal/Equal
    Nat/Nat
    (leaf-count
      Nat/Nat
      (#Node{
        #Zero{}
        (#Node{#Zero{} #Leaf{} #Leaf{}})
        (#Node{#Zero{} #Leaf{} (#Node{#Zero{} #Leaf{} #Leaf{}})})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}
  )
= #Refl{}

// Sums all values in a binary tree of natural numbers
sum-tree
: ∀(tree: (BinTree/BinTree Nat/Nat))
  Nat/Nat
= λtree
  (BinTree/match Nat/Nat (λx Nat/Nat) #Zero{} (λval λlft λrgt λl λr (Nat/add val (Nat/add l r))) tree)

// Test: Sum of values (for Nat trees)
TEST_3
: (Equal/Equal
    Nat/Nat
    (sum-tree
      (#Node{
        #Succ{#Succ{#Zero{}}}
        (#Node{#Succ{#Zero{}} #Leaf{} #Leaf{}})
        (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}
  )
= #Refl{}
