// Creates a binary tree node with a value and left and right subtrees.
// - 1st: The type of values stored in the tree.
// - 2nd: The value stored in this node.
// - 3rd: The left subtree.
// - 4th: The right subtree.
// = A new binary tree node.
BinTree/node
: ∀(A: *)
  ∀(value: A)
  ∀(left: (BinTree/BinTree A))
  ∀(right: (BinTree/BinTree A))
  (BinTree/BinTree A)
= λA λvalue λleft λright
  #Node{value left right}
	
// Test: Create a simple node with two leaf children
TEST_0
: (Equal
    (BinTree/BinTree Nat)
    (BinTree/node Nat #Succ{#Zero} (BinTree/leaf Nat) (BinTree/leaf Nat))
    #Node{#Succ{#Zero} #Leaf #Leaf}
  )
= #Refl

// Test: Create a node with a left child
TEST_1
: (Equal
    (BinTree/BinTree Nat)
    (BinTree/node Nat #Succ{#Succ{#Zero}}
      (BinTree/node Nat #Succ{#Zero} (BinTree/leaf Nat) (BinTree/leaf Nat))
      (BinTree/leaf Nat))
    #Node{#Succ{#Succ{#Zero}} #Node{#Succ{#Zero} #Leaf #Leaf} #Leaf}
  )
= #Refl

// Test: Create a node with a right child
TEST_2
: (Equal
    (BinTree/BinTree Nat)
    (BinTree/node Nat #Succ{#Succ{#Succ{#Zero}}}
      (BinTree/leaf Nat)
      (BinTree/node Nat #Succ{#Succ{#Succ{#Succ{#Zero}}}} (BinTree/leaf Nat) (BinTree/leaf Nat)))
    #Node{#Succ{#Succ{#Succ{#Zero}}} #Leaf #Node{#Succ{#Succ{#Succ{#Succ{#Zero}}}} #Leaf #Leaf}}
  )
= #Refl

// Test: Create a balanced tree with three levels
TEST_3
: (Equal
    (BinTree/BinTree Nat)
    (BinTree/node Nat #Succ{#Zero}
      (BinTree/node Nat #Succ{#Succ{#Zero}} (BinTree/leaf Nat) (BinTree/leaf Nat))
      (BinTree/node Nat #Succ{#Succ{#Succ{#Zero}}} (BinTree/leaf Nat) (BinTree/leaf Nat)))
    #Node{#Succ{#Zero}
      #Node{#Succ{#Succ{#Zero}} #Leaf #Leaf}
      #Node{#Succ{#Succ{#Succ{#Zero}}} #Leaf #Leaf}}
  )
= #Refl
