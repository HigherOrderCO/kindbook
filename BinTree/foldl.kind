// Performs a left-associative fold over a binary tree.
// - 1st: The type of values in the tree
// - 2nd: The type of the accumulator and result
// - 3rd: The folding function
// - 4th: The initial value of the accumulator
// - 5th: The input binary tree
// = The result of folding the tree from left to right
BinTree/foldl
: ∀(A: *)
  ∀(B: *)
  ∀(f: ∀(acc: B) ∀(x: A) B)
  ∀(z: B)
  ∀(t: (BinTree/BinTree A))
  B
= λA λB λf λz λ{
  #Leaf: z
  #Node: λt.val λt.lft λt.rgt
    (BinTree/foldl A B f (f (BinTree/foldl A B f z t.lft) t.val) t.rgt)
}

// Test: Empty tree
TEST_0 
: (Equal 
		Nat
		(BinTree/foldl _ _ 
			Nat/add 
			#Zero 
			#Leaf) 
		#Zero)
= #Refl

// Test: Single node tree
TEST_1 
: (Equal 
		Nat
		(BinTree/foldl _ _ 
			Nat/add 
			#Zero 
			(#Node{#5 #Leaf #Leaf})) 
		#5)
= #Refl

// Test: Tree with multiple nodes
TEST_2 
: (Equal 
		Nat 
		(BinTree/foldl _ _ 
			Nat/add 
			#Zero 
			(#Node{#1 
				(#Node{#2 #Leaf #Leaf}) 
				(#Node{#3 #Leaf #Leaf})})) 
		#6)
= #Refl

// Test: Using multiplication instead of addition
TEST_3 
: (Equal 
		Nat 
		(BinTree/foldl _ _ 
			Nat/mul 
			#1 
			(#Node{#2 
				(#Node{#3 #Leaf #Leaf}) 
				(#Node{#4 #Leaf #Leaf})})) 
		#24)
= #Refl

// Test: Using a more complex tree structure
TEST_4 
: (Equal 
		Nat 
		(BinTree/foldl _ _ 
			Nat/add 
			#Zero 
			(#Node{#1 
				(#Node{#2 
					(#Node{#3 #Leaf #Leaf}) 
					#Leaf}) 
				(#Node{#4 
					#Leaf 
					(#Node{#5 #Leaf #Leaf})})})) 
		#15)
= #Refl
