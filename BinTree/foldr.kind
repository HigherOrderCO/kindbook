// Performs a right-associative fold over a binary tree.
// - 1st: The type of values in the tree.
// - 2nd: The type of the accumulator and result.
// - 3rd: The folding function.
// - 4th: The initial value of the accumulator.
// - 5th: The input binary tree.
// = The result of folding the tree from right to left.
BinTree/foldr
: ∀(A: *)
  ∀(B: *)
  ∀(f: ∀(x: A) ∀(acc: B) B)
  ∀(z: B)
  ∀(t: (BinTree/BinTree A))
  B
= λA λB λf λz λ{
  #Leaf: z
  #Node: λt.val λt.lft λt.rgt
    (f t.val (BinTree/foldr A B f (BinTree/foldr A B f z t.rgt) t.lft))
}

// Test: Empty tree
TEST_0 
: (Equal/Equal Nat/Nat (BinTree/foldr _ _ Nat/add #Zero{} #Leaf{}) #Zero{})
= #Refl{}

// Test: Single node tree
TEST_1 
: (Equal/Equal 
		Nat/Nat 
		(BinTree/foldr _ _ 
			Nat/add 
			#Zero{} 
			(#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}})) 
		#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}})
= #Refl{}

// Test: Tree with multiple nodes
TEST_2 
: (Equal/Equal 
		Nat/Nat 
		(BinTree/foldr _ _ 
			Nat/add 
			#Zero{} 
			(#Node{#Succ{#Zero{}} 
				(#Node{#Succ{#Succ{#Zero{}}} #Leaf{} #Leaf{}}) 
				(#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})})) 
		#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}})
= #Refl{}

// Test: Using multiplication instead of addition
TEST_3 
: (Equal/Equal
	 	Nat/Nat 
		(BinTree/foldr _ _ 
			Nat/mul 
			#Succ{#Zero{}} 
			(#Node{#Succ{#Succ{#Zero{}}} 
				(#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}}) 
				(#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})})) 
		#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Using a more complex tree structure
TEST_4 
: (Equal/Equal 
		Nat/Nat 
		(BinTree/foldr _ _ 
			Nat/add 
			#Zero{} 
			(#Node{#Succ{#Zero{}} 
				(#Node{#Succ{#Succ{#Zero{}}} 
					(#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}}) 
					#Leaf{}}) 
				(#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} 
					#Leaf{} 
					(#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}})})})) 
		#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Right-associative nature of foldr
TEST_5 
: (Equal/Equal 
		Nat/Nat 
		(BinTree/foldr _ _ 
			Nat/sub 
			#Zero{} 
			(#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}} 
				(#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}}) 
				(#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})})) 
		#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}})
= #Refl{}

// Test: Using foldr to count nodes
TEST_6 
: (Equal/Equal 
		Nat/Nat 
		(BinTree/foldr _ _ 
			(λx λacc #Succ{acc}) 
			#Zero{} 
			(#Node{#Succ{#Zero{}} 
				(#Node{#Succ{#Succ{#Zero{}}} #Leaf{} #Leaf{}}) 
				(#Node{#Succ{#Succ{#Succ{#Zero{}}}} 
					#Leaf{} 
					(#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})})})) 
			#Succ{#Succ{#Succ{#Succ{#Zero{}}}}})
= #Refl{}
