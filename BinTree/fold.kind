use BinTree/ as BT/

// Performs a fold operation on a binary tree.
// - 1st: The type of elements in the tree.
// - 2nd: The type of the result.
// - 3rd: Function to apply to each node.
// - 4th: Value to use for leaf nodes.
// - 5th: The tree to fold over.
// = The result of folding the tree.
BT/fold
: ∀(A: *)
  ∀(B: *)
  ∀(f: ∀(x: A) ∀(l: B) ∀(r: B) B)
  ∀(z: B)
  ∀(t: (BT/BinTree A))
  B
= λA λB λf λz λ{
  #Leaf: z
  #Node: λt.val λt.lft λt.rgt
    (f t.val
      (BT/fold A B f z t.lft)
      (BT/fold A B f z t.rgt))
}

//TEST//

use BinTree/ as BT/
use Equal/ as E/
use Nat/ as N/
use Bool/ as B/

// Test: Folding a leaf tree
T0
: (E/Equal N/Nat (BT/fold N/Nat N/Nat (λx λl λr (N/add x (N/add l r))) #Zero{} #Leaf{}) #Zero{})
= #Refl{}

// Test: Folding a simple tree with addition
T1
: (E/Equal
    N/Nat
    (BT/fold
      N/Nat
      N/Nat
      (λx λl λr (N/add x (N/add l r)))
      #Zero{}
      (#Node{
        #Succ{#Zero{}}
        (#Node{#Succ{#Succ{#Zero{}}} #Leaf{} #Leaf{}})
        (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}})
= #Refl{}

// Test: Folding a tree with boolean OR operation
T2
: (E/Equal
    B/Bool
    (BT/fold
      B/Bool
      B/Bool
      (λx λl λr (B/or x (B/or l r)))
      #False{}
      (#Node{
        #True{}
        (#Node{#False{} #Leaf{} #Leaf{}})
        (#Node{#False{} #Leaf{} #Leaf{}})
      }))
    #True{})
= #Refl{}

// Test: Folding a more complex tree with addition
T3
: (E/Equal
    N/Nat
    (BT/fold
      N/Nat
      N/Nat
      (λx λl λr (N/add x (N/add l r)))
      #Zero{}
      (#Node{
        #Succ{#Zero{}}
        (#Node{
          #Succ{#Succ{#Zero{}}}
          (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
          (#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})
        })
        (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Folding a tree with multiplication
T4
: (E/Equal
    N/Nat
    (BT/fold
      N/Nat
      N/Nat
      (λx λl λr (N/mul x (N/mul l r)))
      #Succ{#Zero{}}
      (#Node{
        #Succ{#Succ{#Zero{}}}
        (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
        (#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Folding a tree to find the maximum value
T5
: (E/Equal
    N/Nat
    (BT/fold
      N/Nat
      N/Nat
      (λx λl λr (N/max x (N/max l r)))
      #Zero{}
      (#Node{
        #Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}
        (#Node{
          #Succ{#Succ{#Succ{#Zero{}}}}
          (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}} #Leaf{} #Leaf{}})
          #Leaf{}
        })
        (#Node{
          #Succ{#Succ{#Zero{}}}
          #Leaf{}
          (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}} #Leaf{} #Leaf{}})
        })
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}})
= #Refl{}
