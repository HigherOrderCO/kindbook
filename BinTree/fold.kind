// Performs a fold operation on a binary tree.
// - 1st: The type of elements in the tree.
// - 2nd: The type of the result.
// - 3rd: Function to apply to each node.
// - 4th: Value to use for leaf nodes.
// - 5th: The tree to fold over.
// = The result of folding the tree.
BinTree/fold
: ∀(A: *)
  ∀(B: *)
  ∀(f: ∀(x: A) ∀(l: B) ∀(r: B) B)
  ∀(z: B)
  ∀(t: (BinTree/BinTree A))
  B
= λA λB λf λz λ{
  #Leaf: z
  #Node: λt.val λt.lft λt.rgt
    (f t.val
      (BinTree/fold A B f z t.lft)
      (BinTree/fold A B f z t.rgt))
}

// Test: Folding a leaf tree
TEST_0
: (Equal/Equal Nat/Nat (BinTree/fold Nat/Nat Nat/Nat (λx λl λr (Nat/add x (Nat/add l r))) #Zero{} #Leaf{}) #Zero{})
= #Refl{}

// Test: Folding a simple tree with addition
TEST_1
: (Equal/Equal
    Nat/Nat
    (BinTree/fold
      Nat/Nat
      Nat/Nat
      (λx λl λr (Nat/add x (Nat/add l r)))
      #Zero{}
      (#Node{
        #Succ{#Zero{}}
        (#Node{#Succ{#Succ{#Zero{}}} #Leaf{} #Leaf{}})
        (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}})
= #Refl{}

// Test: Folding a tree with boolean OR operation
TEST_2
: (Equal/Equal
    Bool/Bool
    (BinTree/fold
      Bool/Bool
      Bool/Bool
      (λx λl λr (Bool/or x (Bool/or l r)))
      #False{}
      (#Node{
        #True{}
        (#Node{#False{} #Leaf{} #Leaf{}})
        (#Node{#False{} #Leaf{} #Leaf{}})
      }))
    #True{})
= #Refl{}

// Test: Folding a more complex tree with addition
TEST_3
: (Equal/Equal
    Nat/Nat
    (BinTree/fold
      Nat/Nat
      Nat/Nat
      (λx λl λr (Nat/add x (Nat/add l r)))
      #Zero{}
      (#Node{
        #Succ{#Zero{}}
        (#Node{
          #Succ{#Succ{#Zero{}}}
          (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
          (#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})
        })
        (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Folding a tree with multiplication
TEST_4
: (Equal/Equal
    Nat/Nat
    (BinTree/fold
      Nat/Nat
      Nat/Nat
      (λx λl λr (Nat/mul x (Nat/mul l r)))
      #Succ{#Zero{}}
      (#Node{
        #Succ{#Succ{#Zero{}}}
        (#Node{#Succ{#Succ{#Succ{#Zero{}}}} #Leaf{} #Leaf{}})
        (#Node{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}} #Leaf{} #Leaf{}})
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}}}}}}}}}}}}}}}}}}})
= #Refl{}

// Test: Folding a tree to find the maximum value
TEST_5
: (Equal/Equal
    Nat/Nat
    (BinTree/fold
      Nat/Nat
      Nat/Nat
      (λx λl λr (Nat/max x (Nat/max l r)))
      #Zero{}
      (#Node{
        #Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}
        (#Node{
          #Succ{#Succ{#Succ{#Zero{}}}}
          (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}} #Leaf{} #Leaf{}})
          #Leaf{}
        })
        (#Node{
          #Succ{#Succ{#Zero{}}}
          #Leaf{}
          (#Node{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}} #Leaf{} #Leaf{}})
        })
      }))
    #Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Succ{#Zero{}}}}}}}})
= #Refl{}
