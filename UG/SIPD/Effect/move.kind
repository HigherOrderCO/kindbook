
use UG/SIPD as G

UG/SIPD/Effect/move : U64 -> U64 -> G/Effect
| pid body_id #State{next_id tick players hero_states #GameMap{width height bodies}} with ((G/Player/get_player players pid) , (G/GameMap/get_body bodies body_id)) :: (Pair _ _)
.| #None   _       = #State{next_id tick players hero_states #GameMap{width height bodies}}
.| _       #None   = #State{next_id tick players hero_states #GameMap{width height bodies}}
.| #Some{#Player{id name keys target hero}} #Some{#Body{id hitbox body_tick effects collidable}} =
  let hitbox_center = (UG/Shape/get_center hitbox)
  let distance_to_target = (V2/sub target hitbox_center)
  let ln = (V2/length distance_to_target)
  
  if (F64/lt ln 0.1) {
    #State{next_id tick players hero_states #GameMap{width height bodies}}
  } else {
    let constant_speed = 3.0
    let direction = (V2/normalize distance_to_target)
    let movement = (V2/mul_scalar direction (F64/min constant_speed ln))
    let new_center = (V2/add hitbox_center movement)

    // TODO implement collide and slide
    // probably shouldnt transform ordmap to list every tick
    //let #Pair{final_movement collision_rest) = (collide_and_slide

    let new_hitbox = (UG/Shape/move hitbox (V2/sub movement hitbox_center))

    (G/State/insert_body #State{next_id tick players hero_states #GameMap{width height bodies}} #Body{id new_hitbox body_tick effects collidable})
  }
  
